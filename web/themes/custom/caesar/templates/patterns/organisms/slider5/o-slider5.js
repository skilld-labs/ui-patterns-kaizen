var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
/**
  * DO NOT EDIT THIS FILE.
  * It's generated automatically by 'yarn build' command.
  * @preserve
**/
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = window, e$2 = t$1.ShadowRoot && (void 0 === t$1.ShadyCSS || t$1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$3 = Symbol(), n$3 = /* @__PURE__ */ new WeakMap();
let o$3 = class o {
  constructor(t2, e2, n2) {
    if (this._$cssResult$ = true, n2 !== s$3)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s2 = this.t;
    if (e$2 && void 0 === t2) {
      const e2 = void 0 !== s2 && 1 === s2.length;
      e2 && (t2 = n$3.get(s2)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && n$3.set(s2, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$2 = (t2) => new o$3("string" == typeof t2 ? t2 : t2 + "", void 0, s$3), i$1 = (t2, ...e2) => {
  const n2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s2, n3) => e3 + ((t3) => {
    if (true === t3._$cssResult$)
      return t3.cssText;
    if ("number" == typeof t3)
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s2) + t2[n3 + 1], t2[0]);
  return new o$3(n2, t2, s$3);
}, S$1 = (s2, n2) => {
  e$2 ? s2.adoptedStyleSheets = n2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet) : n2.forEach((e2) => {
    const n3 = document.createElement("style"), o3 = t$1.litNonce;
    void 0 !== o3 && n3.setAttribute("nonce", o3), n3.textContent = e2.cssText, s2.appendChild(n3);
  });
}, c$1 = e$2 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s2 of t3.cssRules)
    e2 += s2.cssText;
  return r$2(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var s$2;
const e$1 = window, r$1 = e$1.trustedTypes, h$1 = r$1 ? r$1.emptyScript : "", o$2 = e$1.reactiveElementPolyfillSupport, n$2 = { toAttribute(t2, i2) {
  switch (i2) {
    case Boolean:
      t2 = t2 ? h$1 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, i2) {
  let s2 = t2;
  switch (i2) {
    case Boolean:
      s2 = null !== t2;
      break;
    case Number:
      s2 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        s2 = JSON.parse(t2);
      } catch (t3) {
        s2 = null;
      }
  }
  return s2;
} }, a$1 = (t2, i2) => i2 !== t2 && (i2 == i2 || t2 == t2), l$2 = { attribute: true, type: String, converter: n$2, reflect: false, hasChanged: a$1 };
let d$1 = class d extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
  }
  static addInitializer(t2) {
    var i2;
    this.finalize(), (null !== (i2 = this.h) && void 0 !== i2 ? i2 : this.h = []).push(t2);
  }
  static get observedAttributes() {
    this.finalize();
    const t2 = [];
    return this.elementProperties.forEach((i2, s2) => {
      const e2 = this._$Ep(s2, i2);
      void 0 !== e2 && (this._$Ev.set(e2, s2), t2.push(e2));
    }), t2;
  }
  static createProperty(t2, i2 = l$2) {
    if (i2.state && (i2.attribute = false), this.finalize(), this.elementProperties.set(t2, i2), !i2.noAccessor && !this.prototype.hasOwnProperty(t2)) {
      const s2 = "symbol" == typeof t2 ? Symbol() : "__" + t2, e2 = this.getPropertyDescriptor(t2, s2, i2);
      void 0 !== e2 && Object.defineProperty(this.prototype, t2, e2);
    }
  }
  static getPropertyDescriptor(t2, i2, s2) {
    return { get() {
      return this[i2];
    }, set(e2) {
      const r2 = this[t2];
      this[i2] = e2, this.requestUpdate(t2, r2, s2);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) || l$2;
  }
  static finalize() {
    if (this.hasOwnProperty("finalized"))
      return false;
    this.finalized = true;
    const t2 = Object.getPrototypeOf(this);
    if (t2.finalize(), void 0 !== t2.h && (this.h = [...t2.h]), this.elementProperties = new Map(t2.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t3 = this.properties, i2 = [...Object.getOwnPropertyNames(t3), ...Object.getOwnPropertySymbols(t3)];
      for (const s2 of i2)
        this.createProperty(s2, t3[s2]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i2) {
    const s2 = [];
    if (Array.isArray(i2)) {
      const e2 = new Set(i2.flat(1 / 0).reverse());
      for (const i3 of e2)
        s2.unshift(c$1(i3));
    } else
      void 0 !== i2 && s2.push(c$1(i2));
    return s2;
  }
  static _$Ep(t2, i2) {
    const s2 = i2.attribute;
    return false === s2 ? void 0 : "string" == typeof s2 ? s2 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  u() {
    var t2;
    this._$E_ = new Promise((t3) => this.enableUpdating = t3), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t2 = this.constructor.h) || void 0 === t2 || t2.forEach((t3) => t3(this));
  }
  addController(t2) {
    var i2, s2;
    (null !== (i2 = this._$ES) && void 0 !== i2 ? i2 : this._$ES = []).push(t2), void 0 !== this.renderRoot && this.isConnected && (null === (s2 = t2.hostConnected) || void 0 === s2 || s2.call(t2));
  }
  removeController(t2) {
    var i2;
    null === (i2 = this._$ES) || void 0 === i2 || i2.splice(this._$ES.indexOf(t2) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t2, i2) => {
      this.hasOwnProperty(i2) && (this._$Ei.set(i2, this[i2]), delete this[i2]);
    });
  }
  createRenderRoot() {
    var t2;
    const s2 = null !== (t2 = this.shadowRoot) && void 0 !== t2 ? t2 : this.attachShadow(this.constructor.shadowRootOptions);
    return S$1(s2, this.constructor.elementStyles), s2;
  }
  connectedCallback() {
    var t2;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((t3) => {
      var i2;
      return null === (i2 = t3.hostConnected) || void 0 === i2 ? void 0 : i2.call(t3);
    });
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    var t2;
    null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((t3) => {
      var i2;
      return null === (i2 = t3.hostDisconnected) || void 0 === i2 ? void 0 : i2.call(t3);
    });
  }
  attributeChangedCallback(t2, i2, s2) {
    this._$AK(t2, s2);
  }
  _$EO(t2, i2, s2 = l$2) {
    var e2;
    const r2 = this.constructor._$Ep(t2, s2);
    if (void 0 !== r2 && true === s2.reflect) {
      const h2 = (void 0 !== (null === (e2 = s2.converter) || void 0 === e2 ? void 0 : e2.toAttribute) ? s2.converter : n$2).toAttribute(i2, s2.type);
      this._$El = t2, null == h2 ? this.removeAttribute(r2) : this.setAttribute(r2, h2), this._$El = null;
    }
  }
  _$AK(t2, i2) {
    var s2;
    const e2 = this.constructor, r2 = e2._$Ev.get(t2);
    if (void 0 !== r2 && this._$El !== r2) {
      const t3 = e2.getPropertyOptions(r2), h2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== (null === (s2 = t3.converter) || void 0 === s2 ? void 0 : s2.fromAttribute) ? t3.converter : n$2;
      this._$El = r2, this[r2] = h2.fromAttribute(i2, t3.type), this._$El = null;
    }
  }
  requestUpdate(t2, i2, s2) {
    let e2 = true;
    void 0 !== t2 && (((s2 = s2 || this.constructor.getPropertyOptions(t2)).hasChanged || a$1)(this[t2], i2) ? (this._$AL.has(t2) || this._$AL.set(t2, i2), true === s2.reflect && this._$El !== t2 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t2, s2))) : e2 = false), !this.isUpdatePending && e2 && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = true;
    try {
      await this._$E_;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t2;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((t3, i3) => this[i3] = t3), this._$Ei = void 0);
    let i2 = false;
    const s2 = this._$AL;
    try {
      i2 = this.shouldUpdate(s2), i2 ? (this.willUpdate(s2), null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((t3) => {
        var i3;
        return null === (i3 = t3.hostUpdate) || void 0 === i3 ? void 0 : i3.call(t3);
      }), this.update(s2)) : this._$Ek();
    } catch (t3) {
      throw i2 = false, this._$Ek(), t3;
    }
    i2 && this._$AE(s2);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    var i2;
    null === (i2 = this._$ES) || void 0 === i2 || i2.forEach((t3) => {
      var i3;
      return null === (i3 = t3.hostUpdated) || void 0 === i3 ? void 0 : i3.call(t3);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    void 0 !== this._$EC && (this._$EC.forEach((t3, i2) => this._$EO(i2, this[i2], t3)), this._$EC = void 0), this._$Ek();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
d$1.finalized = true, d$1.elementProperties = /* @__PURE__ */ new Map(), d$1.elementStyles = [], d$1.shadowRootOptions = { mode: "open" }, null == o$2 || o$2({ ReactiveElement: d$1 }), (null !== (s$2 = e$1.reactiveElementVersions) && void 0 !== s$2 ? s$2 : e$1.reactiveElementVersions = []).push("1.6.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t;
const i = window, s$1 = i.trustedTypes, e = s$1 ? s$1.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, o$1 = `lit$${(Math.random() + "").slice(9)}$`, n$1 = "?" + o$1, l$1 = `<${n$1}>`, h = document, r = (t2 = "") => h.createComment(t2), d2 = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, u = Array.isArray, c = (t2) => u(t2) || "function" == typeof (null == t2 ? void 0 : t2[Symbol.iterator]), v = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, a = /-->/g, f = />/g, _ = RegExp(`>|[ 	
\f\r](?:([^\\s"'>=/]+)([ 	
\f\r]*=[ 	
\f\r]*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), m = /'/g, p = /"/g, $ = /^(?:script|style|textarea|title)$/i, g = (t2) => (i2, ...s2) => ({ _$litType$: t2, strings: i2, values: s2 }), y = g(1), x = Symbol.for("lit-noChange"), b = Symbol.for("lit-nothing"), T = /* @__PURE__ */ new WeakMap(), A = h.createTreeWalker(h, 129, null, false), E = (t2, i2) => {
  const s2 = t2.length - 1, n2 = [];
  let h2, r2 = 2 === i2 ? "<svg>" : "", d3 = v;
  for (let i3 = 0; i3 < s2; i3++) {
    const s3 = t2[i3];
    let e2, u3, c2 = -1, g2 = 0;
    for (; g2 < s3.length && (d3.lastIndex = g2, u3 = d3.exec(s3), null !== u3); )
      g2 = d3.lastIndex, d3 === v ? "!--" === u3[1] ? d3 = a : void 0 !== u3[1] ? d3 = f : void 0 !== u3[2] ? ($.test(u3[2]) && (h2 = RegExp("</" + u3[2], "g")), d3 = _) : void 0 !== u3[3] && (d3 = _) : d3 === _ ? ">" === u3[0] ? (d3 = null != h2 ? h2 : v, c2 = -1) : void 0 === u3[1] ? c2 = -2 : (c2 = d3.lastIndex - u3[2].length, e2 = u3[1], d3 = void 0 === u3[3] ? _ : '"' === u3[3] ? p : m) : d3 === p || d3 === m ? d3 = _ : d3 === a || d3 === f ? d3 = v : (d3 = _, h2 = void 0);
    const y2 = d3 === _ && t2[i3 + 1].startsWith("/>") ? " " : "";
    r2 += d3 === v ? s3 + l$1 : c2 >= 0 ? (n2.push(e2), s3.slice(0, c2) + "$lit$" + s3.slice(c2) + o$1 + y2) : s3 + o$1 + (-2 === c2 ? (n2.push(void 0), i3) : y2);
  }
  const u2 = r2 + (t2[s2] || "<?>") + (2 === i2 ? "</svg>" : "");
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return [void 0 !== e ? e.createHTML(u2) : u2, n2];
};
class C {
  constructor({ strings: t2, _$litType$: i2 }, e2) {
    let l2;
    this.parts = [];
    let h2 = 0, d3 = 0;
    const u2 = t2.length - 1, c2 = this.parts, [v2, a2] = E(t2, i2);
    if (this.el = C.createElement(v2, e2), A.currentNode = this.el.content, 2 === i2) {
      const t3 = this.el.content, i3 = t3.firstChild;
      i3.remove(), t3.append(...i3.childNodes);
    }
    for (; null !== (l2 = A.nextNode()) && c2.length < u2; ) {
      if (1 === l2.nodeType) {
        if (l2.hasAttributes()) {
          const t3 = [];
          for (const i3 of l2.getAttributeNames())
            if (i3.endsWith("$lit$") || i3.startsWith(o$1)) {
              const s2 = a2[d3++];
              if (t3.push(i3), void 0 !== s2) {
                const t4 = l2.getAttribute(s2.toLowerCase() + "$lit$").split(o$1), i4 = /([.?@])?(.*)/.exec(s2);
                c2.push({ type: 1, index: h2, name: i4[2], strings: t4, ctor: "." === i4[1] ? M : "?" === i4[1] ? k : "@" === i4[1] ? H : S });
              } else
                c2.push({ type: 6, index: h2 });
            }
          for (const i3 of t3)
            l2.removeAttribute(i3);
        }
        if ($.test(l2.tagName)) {
          const t3 = l2.textContent.split(o$1), i3 = t3.length - 1;
          if (i3 > 0) {
            l2.textContent = s$1 ? s$1.emptyScript : "";
            for (let s2 = 0; s2 < i3; s2++)
              l2.append(t3[s2], r()), A.nextNode(), c2.push({ type: 2, index: ++h2 });
            l2.append(t3[i3], r());
          }
        }
      } else if (8 === l2.nodeType)
        if (l2.data === n$1)
          c2.push({ type: 2, index: h2 });
        else {
          let t3 = -1;
          for (; -1 !== (t3 = l2.data.indexOf(o$1, t3 + 1)); )
            c2.push({ type: 7, index: h2 }), t3 += o$1.length - 1;
        }
      h2++;
    }
  }
  static createElement(t2, i2) {
    const s2 = h.createElement("template");
    return s2.innerHTML = t2, s2;
  }
}
function P(t2, i2, s2 = t2, e2) {
  var o3, n2, l2, h2;
  if (i2 === x)
    return i2;
  let r2 = void 0 !== e2 ? null === (o3 = s2._$Co) || void 0 === o3 ? void 0 : o3[e2] : s2._$Cl;
  const u2 = d2(i2) ? void 0 : i2._$litDirective$;
  return (null == r2 ? void 0 : r2.constructor) !== u2 && (null === (n2 = null == r2 ? void 0 : r2._$AO) || void 0 === n2 || n2.call(r2, false), void 0 === u2 ? r2 = void 0 : (r2 = new u2(t2), r2._$AT(t2, s2, e2)), void 0 !== e2 ? (null !== (l2 = (h2 = s2)._$Co) && void 0 !== l2 ? l2 : h2._$Co = [])[e2] = r2 : s2._$Cl = r2), void 0 !== r2 && (i2 = P(t2, r2._$AS(t2, i2.values), r2, e2)), i2;
}
class V {
  constructor(t2, i2) {
    this.u = [], this._$AN = void 0, this._$AD = t2, this._$AM = i2;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  v(t2) {
    var i2;
    const { el: { content: s2 }, parts: e2 } = this._$AD, o3 = (null !== (i2 = null == t2 ? void 0 : t2.creationScope) && void 0 !== i2 ? i2 : h).importNode(s2, true);
    A.currentNode = o3;
    let n2 = A.nextNode(), l2 = 0, r2 = 0, d3 = e2[0];
    for (; void 0 !== d3; ) {
      if (l2 === d3.index) {
        let i3;
        2 === d3.type ? i3 = new N(n2, n2.nextSibling, this, t2) : 1 === d3.type ? i3 = new d3.ctor(n2, d3.name, d3.strings, this, t2) : 6 === d3.type && (i3 = new I(n2, this, t2)), this.u.push(i3), d3 = e2[++r2];
      }
      l2 !== (null == d3 ? void 0 : d3.index) && (n2 = A.nextNode(), l2++);
    }
    return o3;
  }
  p(t2) {
    let i2 = 0;
    for (const s2 of this.u)
      void 0 !== s2 && (void 0 !== s2.strings ? (s2._$AI(t2, s2, i2), i2 += s2.strings.length - 2) : s2._$AI(t2[i2])), i2++;
  }
}
class N {
  constructor(t2, i2, s2, e2) {
    var o3;
    this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t2, this._$AB = i2, this._$AM = s2, this.options = e2, this._$Cm = null === (o3 = null == e2 ? void 0 : e2.isConnected) || void 0 === o3 || o3;
  }
  get _$AU() {
    var t2, i2;
    return null !== (i2 = null === (t2 = this._$AM) || void 0 === t2 ? void 0 : t2._$AU) && void 0 !== i2 ? i2 : this._$Cm;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i2 = this._$AM;
    return void 0 !== i2 && 11 === t2.nodeType && (t2 = i2.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i2 = this) {
    t2 = P(this, t2, i2), d2(t2) ? t2 === b || null == t2 || "" === t2 ? (this._$AH !== b && this._$AR(), this._$AH = b) : t2 !== this._$AH && t2 !== x && this.g(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : c(t2) ? this.k(t2) : this.g(t2);
  }
  O(t2, i2 = this._$AB) {
    return this._$AA.parentNode.insertBefore(t2, i2);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.O(t2));
  }
  g(t2) {
    this._$AH !== b && d2(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(h.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    var i2;
    const { values: s2, _$litType$: e2 } = t2, o3 = "number" == typeof e2 ? this._$AC(t2) : (void 0 === e2.el && (e2.el = C.createElement(e2.h, this.options)), e2);
    if ((null === (i2 = this._$AH) || void 0 === i2 ? void 0 : i2._$AD) === o3)
      this._$AH.p(s2);
    else {
      const t3 = new V(o3, this), i3 = t3.v(this.options);
      t3.p(s2), this.T(i3), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i2 = T.get(t2.strings);
    return void 0 === i2 && T.set(t2.strings, i2 = new C(t2)), i2;
  }
  k(t2) {
    u(this._$AH) || (this._$AH = [], this._$AR());
    const i2 = this._$AH;
    let s2, e2 = 0;
    for (const o3 of t2)
      e2 === i2.length ? i2.push(s2 = new N(this.O(r()), this.O(r()), this, this.options)) : s2 = i2[e2], s2._$AI(o3), e2++;
    e2 < i2.length && (this._$AR(s2 && s2._$AB.nextSibling, e2), i2.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i2) {
    var s2;
    for (null === (s2 = this._$AP) || void 0 === s2 || s2.call(this, false, true, i2); t2 && t2 !== this._$AB; ) {
      const i3 = t2.nextSibling;
      t2.remove(), t2 = i3;
    }
  }
  setConnected(t2) {
    var i2;
    void 0 === this._$AM && (this._$Cm = t2, null === (i2 = this._$AP) || void 0 === i2 || i2.call(this, t2));
  }
}
class S {
  constructor(t2, i2, s2, e2, o3) {
    this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t2, this.name = i2, this._$AM = e2, this.options = o3, s2.length > 2 || "" !== s2[0] || "" !== s2[1] ? (this._$AH = Array(s2.length - 1).fill(new String()), this.strings = s2) : this._$AH = b;
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2, i2 = this, s2, e2) {
    const o3 = this.strings;
    let n2 = false;
    if (void 0 === o3)
      t2 = P(this, t2, i2, 0), n2 = !d2(t2) || t2 !== this._$AH && t2 !== x, n2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let l2, h2;
      for (t2 = o3[0], l2 = 0; l2 < o3.length - 1; l2++)
        h2 = P(this, e3[s2 + l2], i2, l2), h2 === x && (h2 = this._$AH[l2]), n2 || (n2 = !d2(h2) || h2 !== this._$AH[l2]), h2 === b ? t2 = b : t2 !== b && (t2 += (null != h2 ? h2 : "") + o3[l2 + 1]), this._$AH[l2] = h2;
    }
    n2 && !e2 && this.j(t2);
  }
  j(t2) {
    t2 === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t2 ? t2 : "");
  }
}
class M extends S {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === b ? void 0 : t2;
  }
}
const R = s$1 ? s$1.emptyScript : "";
class k extends S {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    t2 && t2 !== b ? this.element.setAttribute(this.name, R) : this.element.removeAttribute(this.name);
  }
}
class H extends S {
  constructor(t2, i2, s2, e2, o3) {
    super(t2, i2, s2, e2, o3), this.type = 5;
  }
  _$AI(t2, i2 = this) {
    var s2;
    if ((t2 = null !== (s2 = P(this, t2, i2, 0)) && void 0 !== s2 ? s2 : b) === x)
      return;
    const e2 = this._$AH, o3 = t2 === b && e2 !== b || t2.capture !== e2.capture || t2.once !== e2.once || t2.passive !== e2.passive, n2 = t2 !== b && (e2 === b || o3);
    o3 && this.element.removeEventListener(this.name, this, e2), n2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    var i2, s2;
    "function" == typeof this._$AH ? this._$AH.call(null !== (s2 = null === (i2 = this.options) || void 0 === i2 ? void 0 : i2.host) && void 0 !== s2 ? s2 : this.element, t2) : this._$AH.handleEvent(t2);
  }
}
class I {
  constructor(t2, i2, s2) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i2, this.options = s2;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    P(this, t2);
  }
}
const z = i.litHtmlPolyfillSupport;
null == z || z(C, N), (null !== (t = i.litHtmlVersions) && void 0 !== t ? t : i.litHtmlVersions = []).push("2.6.1");
const Z = (t2, i2, s2) => {
  var e2, o3;
  const n2 = null !== (e2 = null == s2 ? void 0 : s2.renderBefore) && void 0 !== e2 ? e2 : i2;
  let l2 = n2._$litPart$;
  if (void 0 === l2) {
    const t3 = null !== (o3 = null == s2 ? void 0 : s2.renderBefore) && void 0 !== o3 ? o3 : null;
    n2._$litPart$ = l2 = new N(i2.insertBefore(r(), t3), t3, void 0, null != s2 ? s2 : {});
  }
  return l2._$AI(t2), l2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var l, o2;
class s extends d$1 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t2, e2;
    const i2 = super.createRenderRoot();
    return null !== (t2 = (e2 = this.renderOptions).renderBefore) && void 0 !== t2 || (e2.renderBefore = i2.firstChild), i2;
  }
  update(t2) {
    const i2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = Z(i2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t2;
    super.connectedCallback(), null === (t2 = this._$Do) || void 0 === t2 || t2.setConnected(true);
  }
  disconnectedCallback() {
    var t2;
    super.disconnectedCallback(), null === (t2 = this._$Do) || void 0 === t2 || t2.setConnected(false);
  }
  render() {
    return x;
  }
}
s.finalized = true, s._$litElement$ = true, null === (l = globalThis.litElementHydrateSupport) || void 0 === l || l.call(globalThis, { LitElement: s });
const n = globalThis.litElementPolyfillSupport;
null == n || n({ LitElement: s });
(null !== (o2 = globalThis.litElementVersions) && void 0 !== o2 ? o2 : globalThis.litElementVersions = []).push("3.2.2");
/*!
 * Glide.js v3.6.0
 * (c) 2013-2022 Jędrzej Chałubek (https://github.com/jedrzejchalubek/)
 * Released under the MIT License.
 */
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var defaults = {
  /**
   * Type of the movement.
   *
   * Available types:
   * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.
   * `carousel` - Changes slides without starting over when it reaches the first or last slide.
   *
   * @type {String}
   */
  type: "slider",
  /**
   * Start at specific slide number defined with zero-based index.
   *
   * @type {Number}
   */
  startAt: 0,
  /**
   * A number of slides visible on the single viewport.
   *
   * @type {Number}
   */
  perView: 1,
  /**
   * Focus currently active slide at a specified position in the track.
   *
   * Available inputs:
   * `center` - Current slide will be always focused at the center of a track.
   * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.
   *
   * @type {String|Number}
   */
  focusAt: 0,
  /**
   * A size of the gap added between slides.
   *
   * @type {Number}
   */
  gap: 10,
  /**
   * Change slides after a specified interval. Use `false` for turning off autoplay.
   *
   * @type {Number|Boolean}
   */
  autoplay: false,
  /**
   * Stop autoplay on mouseover event.
   *
   * @type {Boolean}
   */
  hoverpause: true,
  /**
   * Allow for changing slides with left and right keyboard arrows.
   *
   * @type {Boolean}
   */
  keyboard: true,
  /**
   * Stop running `perView` number of slides from the end. Use this
   * option if you don't want to have an empty space after
   * a slider. Works only with `slider` type and a
   * non-centered `focusAt` setting.
   *
   * @type {Boolean}
   */
  bound: false,
  /**
   * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.
   *
   * @type {Number|Boolean}
   */
  swipeThreshold: 80,
  /**
   * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.
   *
   * @type {Number|Boolean}
   */
  dragThreshold: 120,
  /**
   * A number of slides moved on single swipe.
   *
   * Available types:
   * `` - Moves slider by one slide per swipe
   * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)
   *
   * @type {String}
   */
  perSwipe: "",
  /**
   * Moving distance ratio of the slides on a swiping and dragging.
   *
   * @type {Number}
   */
  touchRatio: 0.5,
  /**
   * Angle required to activate slides moving on swiping or dragging.
   *
   * @type {Number}
   */
  touchAngle: 45,
  /**
   * Duration of the animation in milliseconds.
   *
   * @type {Number}
   */
  animationDuration: 400,
  /**
   * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.
   *
   * @type {Boolean}
   */
  rewind: true,
  /**
   * Duration of the rewinding animation of the `slider` type in milliseconds.
   *
   * @type {Number}
   */
  rewindDuration: 800,
  /**
   * Easing function for the animation.
   *
   * @type {String}
   */
  animationTimingFunc: "cubic-bezier(.165, .840, .440, 1)",
  /**
   * Wait for the animation to finish until the next user input can be processed
   *
   * @type {boolean}
   */
  waitForTransition: true,
  /**
   * Throttle costly events at most once per every wait milliseconds.
   *
   * @type {Number}
   */
  throttle: 10,
  /**
   * Moving direction mode.
   *
   * Available inputs:
   * - 'ltr' - left to right movement,
   * - 'rtl' - right to left movement.
   *
   * @type {String}
   */
  direction: "ltr",
  /**
   * The distance value of the next and previous viewports which
   * have to peek in the current view. Accepts number and
   * pixels as a string. Left and right peeking can be
   * set up separately with a directions object.
   *
   * For example:
   * `100` - Peek 100px on the both sides.
   * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.
   *
   * @type {Number|String|Object}
   */
  peek: 0,
  /**
   * Defines how many clones of current viewport will be generated.
   *
   * @type {Number}
   */
  cloningRatio: 1,
  /**
   * Collection of options applied at specified media breakpoints.
   * For example: display two slides per view under 800px.
   * `{
   *   '800px': {
   *     perView: 2
   *   }
   * }`
   */
  breakpoints: {},
  /**
   * Collection of internally used HTML classes.
   *
   * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object
   * @type {Object}
   */
  classes: {
    swipeable: "glide--swipeable",
    dragging: "glide--dragging",
    direction: {
      ltr: "glide--ltr",
      rtl: "glide--rtl"
    },
    type: {
      slider: "glide--slider",
      carousel: "glide--carousel"
    },
    slide: {
      clone: "glide__slide--clone",
      active: "glide__slide--active"
    },
    arrow: {
      disabled: "glide__arrow--disabled"
    },
    nav: {
      active: "glide__bullet--active"
    }
  }
};
function warn(msg) {
  console.error("[Glide warn]: ".concat(msg));
}
function toInt(value) {
  return parseInt(value);
}
function isString(value) {
  return typeof value === "string";
}
function isObject(value) {
  var type = _typeof(value);
  return type === "function" || type === "object" && !!value;
}
function isFunction(value) {
  return typeof value === "function";
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isArray(value) {
  return value.constructor === Array;
}
function mount(glide, extensions, events) {
  var components = {};
  for (var name in extensions) {
    if (isFunction(extensions[name])) {
      components[name] = extensions[name](glide, components, events);
    } else {
      warn("Extension must be a function");
    }
  }
  for (var _name in components) {
    if (isFunction(components[_name].mount)) {
      components[_name].mount();
    }
  }
  return components;
}
function define(obj, prop, definition) {
  Object.defineProperty(obj, prop, definition);
}
function mergeOptions(defaults2, settings) {
  var options = Object.assign({}, defaults2, settings);
  if (settings.hasOwnProperty("classes")) {
    options.classes = Object.assign({}, defaults2.classes, settings.classes);
    if (settings.classes.hasOwnProperty("direction")) {
      options.classes.direction = Object.assign({}, defaults2.classes.direction, settings.classes.direction);
    }
    if (settings.classes.hasOwnProperty("type")) {
      options.classes.type = Object.assign({}, defaults2.classes.type, settings.classes.type);
    }
    if (settings.classes.hasOwnProperty("slide")) {
      options.classes.slide = Object.assign({}, defaults2.classes.slide, settings.classes.slide);
    }
    if (settings.classes.hasOwnProperty("arrow")) {
      options.classes.arrow = Object.assign({}, defaults2.classes.arrow, settings.classes.arrow);
    }
    if (settings.classes.hasOwnProperty("nav")) {
      options.classes.nav = Object.assign({}, defaults2.classes.nav, settings.classes.nav);
    }
  }
  if (settings.hasOwnProperty("breakpoints")) {
    options.breakpoints = Object.assign({}, defaults2.breakpoints, settings.breakpoints);
  }
  return options;
}
var EventsBus = /* @__PURE__ */ function() {
  function EventsBus2() {
    var events = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, EventsBus2);
    this.events = events;
    this.hop = events.hasOwnProperty;
  }
  _createClass(EventsBus2, [{
    key: "on",
    value: function on(event, handler) {
      if (isArray(event)) {
        for (var i2 = 0; i2 < event.length; i2++) {
          this.on(event[i2], handler);
        }
        return;
      }
      if (!this.hop.call(this.events, event)) {
        this.events[event] = [];
      }
      var index = this.events[event].push(handler) - 1;
      return {
        remove: function remove() {
          delete this.events[event][index];
        }
      };
    }
    /**
     * Runs registered handlers for specified event.
     *
     * @param {String|Array} event
     * @param {Object=} context
     */
  }, {
    key: "emit",
    value: function emit(event, context) {
      if (isArray(event)) {
        for (var i2 = 0; i2 < event.length; i2++) {
          this.emit(event[i2], context);
        }
        return;
      }
      if (!this.hop.call(this.events, event)) {
        return;
      }
      this.events[event].forEach(function(item) {
        item(context || {});
      });
    }
  }]);
  return EventsBus2;
}();
var Glide$1 = /* @__PURE__ */ function() {
  function Glide2(selector) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Glide2);
    this._c = {};
    this._t = [];
    this._e = new EventsBus();
    this.disabled = false;
    this.selector = selector;
    this.settings = mergeOptions(defaults, options);
    this.index = this.settings.startAt;
  }
  _createClass(Glide2, [{
    key: "mount",
    value: function mount$1() {
      var extensions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._e.emit("mount.before");
      if (isObject(extensions)) {
        this._c = mount(this, extensions, this._e);
      } else {
        warn("You need to provide a object on `mount()`");
      }
      this._e.emit("mount.after");
      return this;
    }
    /**
     * Collects an instance `translate` transformers.
     *
     * @param  {Array} transformers Collection of transformers.
     * @return {Void}
     */
  }, {
    key: "mutate",
    value: function mutate() {
      var transformers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (isArray(transformers)) {
        this._t = transformers;
      } else {
        warn("You need to provide a array on `mutate()`");
      }
      return this;
    }
    /**
     * Updates glide with specified settings.
     *
     * @param {Object} settings
     * @return {Glide}
     */
  }, {
    key: "update",
    value: function update() {
      var settings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.settings = mergeOptions(this.settings, settings);
      if (settings.hasOwnProperty("startAt")) {
        this.index = settings.startAt;
      }
      this._e.emit("update");
      return this;
    }
    /**
     * Change slide with specified pattern. A pattern must be in the special format:
     * `>` - Move one forward
     * `<` - Move one backward
     * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)
     * `>>` - Rewinds to end (last slide)
     * `<<` - Rewinds to start (first slide)
     * `|>` - Move one viewport forward
     * `|<` - Move one viewport backward
     *
     * @param {String} pattern
     * @return {Glide}
     */
  }, {
    key: "go",
    value: function go(pattern) {
      this._c.Run.make(pattern);
      return this;
    }
    /**
     * Move track by specified distance.
     *
     * @param {String} distance
     * @return {Glide}
     */
  }, {
    key: "move",
    value: function move(distance) {
      this._c.Transition.disable();
      this._c.Move.make(distance);
      return this;
    }
    /**
     * Destroy instance and revert all changes done by this._c.
     *
     * @return {Glide}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this._e.emit("destroy");
      return this;
    }
    /**
     * Start instance autoplaying.
     *
     * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings
     * @return {Glide}
     */
  }, {
    key: "play",
    value: function play() {
      var interval = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (interval) {
        this.settings.autoplay = interval;
      }
      this._e.emit("play");
      return this;
    }
    /**
     * Stop instance autoplaying.
     *
     * @return {Glide}
     */
  }, {
    key: "pause",
    value: function pause() {
      this._e.emit("pause");
      return this;
    }
    /**
     * Sets glide into a idle status.
     *
     * @return {Glide}
     */
  }, {
    key: "disable",
    value: function disable() {
      this.disabled = true;
      return this;
    }
    /**
     * Sets glide into a active status.
     *
     * @return {Glide}
     */
  }, {
    key: "enable",
    value: function enable() {
      this.disabled = false;
      return this;
    }
    /**
     * Adds cuutom event listener with handler.
     *
     * @param  {String|Array} event
     * @param  {Function} handler
     * @return {Glide}
     */
  }, {
    key: "on",
    value: function on(event, handler) {
      this._e.on(event, handler);
      return this;
    }
    /**
     * Checks if glide is a precised type.
     *
     * @param  {String} name
     * @return {Boolean}
     */
  }, {
    key: "isType",
    value: function isType(name) {
      return this.settings.type === name;
    }
    /**
     * Gets value of the core options.
     *
     * @return {Object}
     */
  }, {
    key: "settings",
    get: function get() {
      return this._o;
    },
    set: function set(o3) {
      if (isObject(o3)) {
        this._o = o3;
      } else {
        warn("Options must be an `object` instance.");
      }
    }
    /**
     * Gets current index of the slider.
     *
     * @return {Object}
     */
  }, {
    key: "index",
    get: function get() {
      return this._i;
    },
    set: function set(i2) {
      this._i = toInt(i2);
    }
    /**
     * Gets type name of the slider.
     *
     * @return {String}
     */
  }, {
    key: "type",
    get: function get() {
      return this.settings.type;
    }
    /**
     * Gets value of the idle status.
     *
     * @return {Boolean}
     */
  }, {
    key: "disabled",
    get: function get() {
      return this._d;
    },
    set: function set(status) {
      this._d = !!status;
    }
  }]);
  return Glide2;
}();
function Run(Glide2, Components, Events) {
  var Run2 = {
    /**
     * Initializes autorunning of the glide.
     *
     * @return {Void}
     */
    mount: function mount2() {
      this._o = false;
    },
    /**
     * Makes glides running based on the passed moving schema.
     *
     * @param {String} move
     */
    make: function make(move) {
      var _this = this;
      if (!Glide2.disabled) {
        !Glide2.settings.waitForTransition || Glide2.disable();
        this.move = move;
        Events.emit("run.before", this.move);
        this.calculate();
        Events.emit("run", this.move);
        Components.Transition.after(function() {
          if (_this.isStart()) {
            Events.emit("run.start", _this.move);
          }
          if (_this.isEnd()) {
            Events.emit("run.end", _this.move);
          }
          if (_this.isOffset()) {
            _this._o = false;
            Events.emit("run.offset", _this.move);
          }
          Events.emit("run.after", _this.move);
          Glide2.enable();
        });
      }
    },
    /**
     * Calculates current index based on defined move.
     *
     * @return {Number|Undefined}
     */
    calculate: function calculate() {
      var move = this.move, length = this.length;
      var steps = move.steps, direction = move.direction;
      var viewSize = 1;
      if (direction === "=") {
        if (Glide2.settings.bound && toInt(steps) > length) {
          Glide2.index = length;
          return;
        }
        Glide2.index = steps;
        return;
      }
      if (direction === ">" && steps === ">") {
        Glide2.index = length;
        return;
      }
      if (direction === "<" && steps === "<") {
        Glide2.index = 0;
        return;
      }
      if (direction === "|") {
        viewSize = Glide2.settings.perView || 1;
      }
      if (direction === ">" || direction === "|" && steps === ">") {
        var index = calculateForwardIndex(viewSize);
        if (index > length) {
          this._o = true;
        }
        Glide2.index = normalizeForwardIndex(index, viewSize);
        return;
      }
      if (direction === "<" || direction === "|" && steps === "<") {
        var _index = calculateBackwardIndex(viewSize);
        if (_index < 0) {
          this._o = true;
        }
        Glide2.index = normalizeBackwardIndex(_index, viewSize);
        return;
      }
      warn("Invalid direction pattern [".concat(direction).concat(steps, "] has been used"));
    },
    /**
     * Checks if we are on the first slide.
     *
     * @return {Boolean}
     */
    isStart: function isStart() {
      return Glide2.index <= 0;
    },
    /**
     * Checks if we are on the last slide.
     *
     * @return {Boolean}
     */
    isEnd: function isEnd() {
      return Glide2.index >= this.length;
    },
    /**
     * Checks if we are making a offset run.
     *
     * @param {String} direction
     * @return {Boolean}
     */
    isOffset: function isOffset() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      if (!direction) {
        return this._o;
      }
      if (!this._o) {
        return false;
      }
      if (direction === "|>") {
        return this.move.direction === "|" && this.move.steps === ">";
      }
      if (direction === "|<") {
        return this.move.direction === "|" && this.move.steps === "<";
      }
      return this.move.direction === direction;
    },
    /**
     * Checks if bound mode is active
     *
     * @return {Boolean}
     */
    isBound: function isBound() {
      return Glide2.isType("slider") && Glide2.settings.focusAt !== "center" && Glide2.settings.bound;
    }
  };
  function calculateForwardIndex(viewSize) {
    var index = Glide2.index;
    if (Glide2.isType("carousel")) {
      return index + viewSize;
    }
    return index + (viewSize - index % viewSize);
  }
  function normalizeForwardIndex(index, viewSize) {
    var length = Run2.length;
    if (index <= length) {
      return index;
    }
    if (Glide2.isType("carousel")) {
      return index - (length + 1);
    }
    if (Glide2.settings.rewind) {
      if (Run2.isBound() && !Run2.isEnd()) {
        return length;
      }
      return 0;
    }
    if (Run2.isBound()) {
      return length;
    }
    return Math.floor(length / viewSize) * viewSize;
  }
  function calculateBackwardIndex(viewSize) {
    var index = Glide2.index;
    if (Glide2.isType("carousel")) {
      return index - viewSize;
    }
    var view = Math.ceil(index / viewSize);
    return (view - 1) * viewSize;
  }
  function normalizeBackwardIndex(index, viewSize) {
    var length = Run2.length;
    if (index >= 0) {
      return index;
    }
    if (Glide2.isType("carousel")) {
      return index + (length + 1);
    }
    if (Glide2.settings.rewind) {
      if (Run2.isBound() && Run2.isStart()) {
        return length;
      }
      return Math.floor(length / viewSize) * viewSize;
    }
    return 0;
  }
  define(Run2, "move", {
    /**
     * Gets value of the move schema.
     *
     * @returns {Object}
     */
    get: function get() {
      return this._m;
    },
    /**
     * Sets value of the move schema.
     *
     * @returns {Object}
     */
    set: function set(value) {
      var step = value.substr(1);
      this._m = {
        direction: value.substr(0, 1),
        steps: step ? toInt(step) ? toInt(step) : step : 0
      };
    }
  });
  define(Run2, "length", {
    /**
     * Gets value of the running distance based
     * on zero-indexing number of slides.
     *
     * @return {Number}
     */
    get: function get() {
      var settings = Glide2.settings;
      var length = Components.Html.slides.length;
      if (this.isBound()) {
        return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);
      }
      return length - 1;
    }
  });
  define(Run2, "offset", {
    /**
     * Gets status of the offsetting flag.
     *
     * @return {Boolean}
     */
    get: function get() {
      return this._o;
    }
  });
  return Run2;
}
function now() {
  return new Date().getTime();
}
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function later2() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function throttled2() {
    var at = now();
    if (!previous && options.leading === false)
      previous = at;
    var remaining = wait - (at - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = at;
      result = func.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var MARGIN_TYPE = {
  ltr: ["marginLeft", "marginRight"],
  rtl: ["marginRight", "marginLeft"]
};
function Gaps(Glide2, Components, Events) {
  var Gaps2 = {
    /**
     * Applies gaps between slides. First and last
     * slides do not receive it's edge margins.
     *
     * @param {HTMLCollection} slides
     * @return {Void}
     */
    apply: function apply(slides) {
      for (var i2 = 0, len = slides.length; i2 < len; i2++) {
        var style = slides[i2].style;
        var direction = Components.Direction.value;
        if (i2 !== 0) {
          style[MARGIN_TYPE[direction][0]] = "".concat(this.value / 2, "px");
        } else {
          style[MARGIN_TYPE[direction][0]] = "";
        }
        if (i2 !== slides.length - 1) {
          style[MARGIN_TYPE[direction][1]] = "".concat(this.value / 2, "px");
        } else {
          style[MARGIN_TYPE[direction][1]] = "";
        }
      }
    },
    /**
     * Removes gaps from the slides.
     *
     * @param {HTMLCollection} slides
     * @returns {Void}
    */
    remove: function remove(slides) {
      for (var i2 = 0, len = slides.length; i2 < len; i2++) {
        var style = slides[i2].style;
        style.marginLeft = "";
        style.marginRight = "";
      }
    }
  };
  define(Gaps2, "value", {
    /**
     * Gets value of the gap.
     *
     * @returns {Number}
     */
    get: function get() {
      return toInt(Glide2.settings.gap);
    }
  });
  define(Gaps2, "grow", {
    /**
     * Gets additional dimensions value caused by gaps.
     * Used to increase width of the slides wrapper.
     *
     * @returns {Number}
     */
    get: function get() {
      return Gaps2.value * Components.Sizes.length;
    }
  });
  define(Gaps2, "reductor", {
    /**
     * Gets reduction value caused by gaps.
     * Used to subtract width of the slides.
     *
     * @returns {Number}
     */
    get: function get() {
      var perView = Glide2.settings.perView;
      return Gaps2.value * (perView - 1) / perView;
    }
  });
  Events.on(["build.after", "update"], throttle(function() {
    Gaps2.apply(Components.Html.wrapper.children);
  }, 30));
  Events.on("destroy", function() {
    Gaps2.remove(Components.Html.wrapper.children);
  });
  return Gaps2;
}
function siblings(node) {
  if (node && node.parentNode) {
    var n2 = node.parentNode.firstChild;
    var matched = [];
    for (; n2; n2 = n2.nextSibling) {
      if (n2.nodeType === 1 && n2 !== node) {
        matched.push(n2);
      }
    }
    return matched;
  }
  return [];
}
function exist(node) {
  if (node && node instanceof window.HTMLElement) {
    return true;
  }
  return false;
}
function toArray(nodeList) {
  return Array.prototype.slice.call(nodeList);
}
var TRACK_SELECTOR = '[data-glide-el="track"]';
function Html(Glide2, Components, Events) {
  var Html2 = {
    /**
     * Setup slider HTML nodes.
     *
     * @param {Glide} glide
     */
    mount: function mount2() {
      this.root = Glide2.selector;
      this.track = this.root.querySelector(TRACK_SELECTOR);
      this.collectSlides();
    },
    /**
     * Collect slides
     */
    collectSlides: function collectSlides() {
      this.slides = toArray(this.wrapper.children).filter(function(slide) {
        return !slide.classList.contains(Glide2.settings.classes.slide.clone);
      });
    }
  };
  define(Html2, "root", {
    /**
     * Gets node of the glide main element.
     *
     * @return {Object}
     */
    get: function get() {
      return Html2._r;
    },
    /**
     * Sets node of the glide main element.
     *
     * @return {Object}
     */
    set: function set(r2) {
      if (isString(r2)) {
        r2 = document.querySelector(r2);
      }
      if (exist(r2)) {
        Html2._r = r2;
      } else {
        warn("Root element must be a existing Html node");
      }
    }
  });
  define(Html2, "track", {
    /**
     * Gets node of the glide track with slides.
     *
     * @return {Object}
     */
    get: function get() {
      return Html2._t;
    },
    /**
     * Sets node of the glide track with slides.
     *
     * @return {Object}
     */
    set: function set(t2) {
      if (exist(t2)) {
        Html2._t = t2;
      } else {
        warn("Could not find track element. Please use ".concat(TRACK_SELECTOR, " attribute."));
      }
    }
  });
  define(Html2, "wrapper", {
    /**
     * Gets node of the slides wrapper.
     *
     * @return {Object}
     */
    get: function get() {
      return Html2.track.children[0];
    }
  });
  Events.on("update", function() {
    Html2.collectSlides();
  });
  return Html2;
}
function Peek(Glide2, Components, Events) {
  var Peek2 = {
    /**
     * Setups how much to peek based on settings.
     *
     * @return {Void}
     */
    mount: function mount2() {
      this.value = Glide2.settings.peek;
    }
  };
  define(Peek2, "value", {
    /**
     * Gets value of the peek.
     *
     * @returns {Number|Object}
     */
    get: function get() {
      return Peek2._v;
    },
    /**
     * Sets value of the peek.
     *
     * @param {Number|Object} value
     * @return {Void}
     */
    set: function set(value) {
      if (isObject(value)) {
        value.before = toInt(value.before);
        value.after = toInt(value.after);
      } else {
        value = toInt(value);
      }
      Peek2._v = value;
    }
  });
  define(Peek2, "reductor", {
    /**
     * Gets reduction value caused by peek.
     *
     * @returns {Number}
     */
    get: function get() {
      var value = Peek2.value;
      var perView = Glide2.settings.perView;
      if (isObject(value)) {
        return value.before / perView + value.after / perView;
      }
      return value * 2 / perView;
    }
  });
  Events.on(["resize", "update"], function() {
    Peek2.mount();
  });
  return Peek2;
}
function Move(Glide2, Components, Events) {
  var Move2 = {
    /**
     * Constructs move component.
     *
     * @returns {Void}
     */
    mount: function mount2() {
      this._o = 0;
    },
    /**
     * Calculates a movement value based on passed offset and currently active index.
     *
     * @param  {Number} offset
     * @return {Void}
     */
    make: function make() {
      var _this = this;
      var offset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.offset = offset;
      Events.emit("move", {
        movement: this.value
      });
      Components.Transition.after(function() {
        Events.emit("move.after", {
          movement: _this.value
        });
      });
    }
  };
  define(Move2, "offset", {
    /**
     * Gets an offset value used to modify current translate.
     *
     * @return {Object}
     */
    get: function get() {
      return Move2._o;
    },
    /**
     * Sets an offset value used to modify current translate.
     *
     * @return {Object}
     */
    set: function set(value) {
      Move2._o = !isUndefined(value) ? toInt(value) : 0;
    }
  });
  define(Move2, "translate", {
    /**
     * Gets a raw movement value.
     *
     * @return {Number}
     */
    get: function get() {
      return Components.Sizes.slideWidth * Glide2.index;
    }
  });
  define(Move2, "value", {
    /**
     * Gets an actual movement value corrected by offset.
     *
     * @return {Number}
     */
    get: function get() {
      var offset = this.offset;
      var translate = this.translate;
      if (Components.Direction.is("rtl")) {
        return translate + offset;
      }
      return translate - offset;
    }
  });
  Events.on(["build.before", "run"], function() {
    Move2.make();
  });
  return Move2;
}
function Sizes(Glide2, Components, Events) {
  var Sizes2 = {
    /**
     * Setups dimensions of slides.
     *
     * @return {Void}
     */
    setupSlides: function setupSlides() {
      var width = "".concat(this.slideWidth, "px");
      var slides = Components.Html.slides;
      for (var i2 = 0; i2 < slides.length; i2++) {
        slides[i2].style.width = width;
      }
    },
    /**
     * Setups dimensions of slides wrapper.
     *
     * @return {Void}
     */
    setupWrapper: function setupWrapper() {
      Components.Html.wrapper.style.width = "".concat(this.wrapperSize, "px");
    },
    /**
     * Removes applied styles from HTML elements.
     *
     * @returns {Void}
     */
    remove: function remove() {
      var slides = Components.Html.slides;
      for (var i2 = 0; i2 < slides.length; i2++) {
        slides[i2].style.width = "";
      }
      Components.Html.wrapper.style.width = "";
    }
  };
  define(Sizes2, "length", {
    /**
     * Gets count number of the slides.
     *
     * @return {Number}
     */
    get: function get() {
      return Components.Html.slides.length;
    }
  });
  define(Sizes2, "width", {
    /**
     * Gets width value of the slider (visible area).
     *
     * @return {Number}
     */
    get: function get() {
      return Components.Html.track.offsetWidth;
    }
  });
  define(Sizes2, "wrapperSize", {
    /**
     * Gets size of the slides wrapper.
     *
     * @return {Number}
     */
    get: function get() {
      return Sizes2.slideWidth * Sizes2.length + Components.Gaps.grow + Components.Clones.grow;
    }
  });
  define(Sizes2, "slideWidth", {
    /**
     * Gets width value of a single slide.
     *
     * @return {Number}
     */
    get: function get() {
      return Sizes2.width / Glide2.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;
    }
  });
  Events.on(["build.before", "resize", "update"], function() {
    Sizes2.setupSlides();
    Sizes2.setupWrapper();
  });
  Events.on("destroy", function() {
    Sizes2.remove();
  });
  return Sizes2;
}
function Build(Glide2, Components, Events) {
  var Build2 = {
    /**
     * Init glide building. Adds classes, sets
     * dimensions and setups initial state.
     *
     * @return {Void}
     */
    mount: function mount2() {
      Events.emit("build.before");
      this.typeClass();
      this.activeClass();
      Events.emit("build.after");
    },
    /**
     * Adds `type` class to the glide element.
     *
     * @return {Void}
     */
    typeClass: function typeClass() {
      Components.Html.root.classList.add(Glide2.settings.classes.type[Glide2.settings.type]);
    },
    /**
     * Sets active class to current slide.
     *
     * @return {Void}
     */
    activeClass: function activeClass() {
      var classes = Glide2.settings.classes;
      var slide = Components.Html.slides[Glide2.index];
      if (slide) {
        slide.classList.add(classes.slide.active);
        siblings(slide).forEach(function(sibling) {
          sibling.classList.remove(classes.slide.active);
        });
      }
    },
    /**
     * Removes HTML classes applied at building.
     *
     * @return {Void}
     */
    removeClasses: function removeClasses() {
      var _Glide$settings$class = Glide2.settings.classes, type = _Glide$settings$class.type, slide = _Glide$settings$class.slide;
      Components.Html.root.classList.remove(type[Glide2.settings.type]);
      Components.Html.slides.forEach(function(sibling) {
        sibling.classList.remove(slide.active);
      });
    }
  };
  Events.on(["destroy", "update"], function() {
    Build2.removeClasses();
  });
  Events.on(["resize", "update"], function() {
    Build2.mount();
  });
  Events.on("move.after", function() {
    Build2.activeClass();
  });
  return Build2;
}
function Clones(Glide2, Components, Events) {
  var Clones2 = {
    /**
     * Create pattern map and collect slides to be cloned.
     */
    mount: function mount2() {
      this.items = [];
      if (Glide2.isType("carousel")) {
        this.items = this.collect();
      }
    },
    /**
     * Collect clones with pattern.
     *
     * @return {[]}
     */
    collect: function collect() {
      var items = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var slides = Components.Html.slides;
      var _Glide$settings = Glide2.settings, perView = _Glide$settings.perView, classes = _Glide$settings.classes, cloningRatio = _Glide$settings.cloningRatio;
      if (slides.length !== 0) {
        var peekIncrementer = +!!Glide2.settings.peek;
        var cloneCount = perView + peekIncrementer + Math.round(perView / 2);
        var append = slides.slice(0, cloneCount).reverse();
        var prepend = slides.slice(cloneCount * -1);
        for (var r2 = 0; r2 < Math.max(cloningRatio, Math.floor(perView / slides.length)); r2++) {
          for (var i2 = 0; i2 < append.length; i2++) {
            var clone = append[i2].cloneNode(true);
            clone.classList.add(classes.slide.clone);
            items.push(clone);
          }
          for (var _i = 0; _i < prepend.length; _i++) {
            var _clone = prepend[_i].cloneNode(true);
            _clone.classList.add(classes.slide.clone);
            items.unshift(_clone);
          }
        }
      }
      return items;
    },
    /**
     * Append cloned slides with generated pattern.
     *
     * @return {Void}
     */
    append: function append() {
      var items = this.items;
      var _Components$Html = Components.Html, wrapper = _Components$Html.wrapper, slides = _Components$Html.slides;
      var half = Math.floor(items.length / 2);
      var prepend = items.slice(0, half).reverse();
      var append2 = items.slice(half * -1).reverse();
      var width = "".concat(Components.Sizes.slideWidth, "px");
      for (var i2 = 0; i2 < append2.length; i2++) {
        wrapper.appendChild(append2[i2]);
      }
      for (var _i2 = 0; _i2 < prepend.length; _i2++) {
        wrapper.insertBefore(prepend[_i2], slides[0]);
      }
      for (var _i3 = 0; _i3 < items.length; _i3++) {
        items[_i3].style.width = width;
      }
    },
    /**
     * Remove all cloned slides.
     *
     * @return {Void}
     */
    remove: function remove() {
      var items = this.items;
      for (var i2 = 0; i2 < items.length; i2++) {
        Components.Html.wrapper.removeChild(items[i2]);
      }
    }
  };
  define(Clones2, "grow", {
    /**
     * Gets additional dimensions value caused by clones.
     *
     * @return {Number}
     */
    get: function get() {
      return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones2.items.length;
    }
  });
  Events.on("update", function() {
    Clones2.remove();
    Clones2.mount();
    Clones2.append();
  });
  Events.on("build.before", function() {
    if (Glide2.isType("carousel")) {
      Clones2.append();
    }
  });
  Events.on("destroy", function() {
    Clones2.remove();
  });
  return Clones2;
}
var EventsBinder = /* @__PURE__ */ function() {
  function EventsBinder2() {
    var listeners = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, EventsBinder2);
    this.listeners = listeners;
  }
  _createClass(EventsBinder2, [{
    key: "on",
    value: function on(events, el, closure) {
      var capture = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (isString(events)) {
        events = [events];
      }
      for (var i2 = 0; i2 < events.length; i2++) {
        this.listeners[events[i2]] = closure;
        el.addEventListener(events[i2], this.listeners[events[i2]], capture);
      }
    }
    /**
     * Removes event listeners from arrows HTML elements.
     *
     * @param  {String|Array} events
     * @param  {Element|Window|Document} el
     * @param  {Boolean|Object} capture
     * @return {Void}
     */
  }, {
    key: "off",
    value: function off(events, el) {
      var capture = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (isString(events)) {
        events = [events];
      }
      for (var i2 = 0; i2 < events.length; i2++) {
        el.removeEventListener(events[i2], this.listeners[events[i2]], capture);
      }
    }
    /**
     * Destroy collected listeners.
     *
     * @returns {Void}
     */
  }, {
    key: "destroy",
    value: function destroy() {
      delete this.listeners;
    }
  }]);
  return EventsBinder2;
}();
function Resize(Glide2, Components, Events) {
  var Binder = new EventsBinder();
  var Resize2 = {
    /**
     * Initializes window bindings.
     */
    mount: function mount2() {
      this.bind();
    },
    /**
     * Binds `rezsize` listener to the window.
     * It's a costly event, so we are debouncing it.
     *
     * @return {Void}
     */
    bind: function bind() {
      Binder.on("resize", window, throttle(function() {
        Events.emit("resize");
      }, Glide2.settings.throttle));
    },
    /**
     * Unbinds listeners from the window.
     *
     * @return {Void}
     */
    unbind: function unbind() {
      Binder.off("resize", window);
    }
  };
  Events.on("destroy", function() {
    Resize2.unbind();
    Binder.destroy();
  });
  return Resize2;
}
var VALID_DIRECTIONS = ["ltr", "rtl"];
var FLIPED_MOVEMENTS = {
  ">": "<",
  "<": ">",
  "=": "="
};
function Direction(Glide2, Components, Events) {
  var Direction2 = {
    /**
     * Setups gap value based on settings.
     *
     * @return {Void}
     */
    mount: function mount2() {
      this.value = Glide2.settings.direction;
    },
    /**
     * Resolves pattern based on direction value
     *
     * @param {String} pattern
     * @returns {String}
     */
    resolve: function resolve(pattern) {
      var token = pattern.slice(0, 1);
      if (this.is("rtl")) {
        return pattern.split(token).join(FLIPED_MOVEMENTS[token]);
      }
      return pattern;
    },
    /**
     * Checks value of direction mode.
     *
     * @param {String} direction
     * @returns {Boolean}
     */
    is: function is(direction) {
      return this.value === direction;
    },
    /**
     * Applies direction class to the root HTML element.
     *
     * @return {Void}
     */
    addClass: function addClass() {
      Components.Html.root.classList.add(Glide2.settings.classes.direction[this.value]);
    },
    /**
     * Removes direction class from the root HTML element.
     *
     * @return {Void}
     */
    removeClass: function removeClass() {
      Components.Html.root.classList.remove(Glide2.settings.classes.direction[this.value]);
    }
  };
  define(Direction2, "value", {
    /**
     * Gets value of the direction.
     *
     * @returns {Number}
     */
    get: function get() {
      return Direction2._v;
    },
    /**
     * Sets value of the direction.
     *
     * @param {String} value
     * @return {Void}
     */
    set: function set(value) {
      if (VALID_DIRECTIONS.indexOf(value) > -1) {
        Direction2._v = value;
      } else {
        warn("Direction value must be `ltr` or `rtl`");
      }
    }
  });
  Events.on(["destroy", "update"], function() {
    Direction2.removeClass();
  });
  Events.on("update", function() {
    Direction2.mount();
  });
  Events.on(["build.before", "update"], function() {
    Direction2.addClass();
  });
  return Direction2;
}
function Rtl(Glide2, Components) {
  return {
    /**
     * Negates the passed translate if glide is in RTL option.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function modify(translate) {
      if (Components.Direction.is("rtl")) {
        return -translate;
      }
      return translate;
    }
  };
}
function Gap(Glide2, Components) {
  return {
    /**
     * Modifies passed translate value with number in the `gap` settings.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function modify(translate) {
      var multiplier = Math.floor(translate / Components.Sizes.slideWidth);
      return translate + Components.Gaps.value * multiplier;
    }
  };
}
function Grow(Glide2, Components) {
  return {
    /**
     * Adds to the passed translate width of the half of clones.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function modify(translate) {
      return translate + Components.Clones.grow / 2;
    }
  };
}
function Peeking(Glide2, Components) {
  return {
    /**
     * Modifies passed translate value with a `peek` setting.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function modify(translate) {
      if (Glide2.settings.focusAt >= 0) {
        var peek = Components.Peek.value;
        if (isObject(peek)) {
          return translate - peek.before;
        }
        return translate - peek;
      }
      return translate;
    }
  };
}
function Focusing(Glide2, Components) {
  return {
    /**
     * Modifies passed translate value with index in the `focusAt` setting.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    modify: function modify(translate) {
      var gap = Components.Gaps.value;
      var width = Components.Sizes.width;
      var focusAt = Glide2.settings.focusAt;
      var slideWidth = Components.Sizes.slideWidth;
      if (focusAt === "center") {
        return translate - (width / 2 - slideWidth / 2);
      }
      return translate - slideWidth * focusAt - gap * focusAt;
    }
  };
}
function mutator(Glide2, Components, Events) {
  var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide2._t, [Rtl]);
  return {
    /**
     * Piplines translate value with registered transformers.
     *
     * @param  {Number} translate
     * @return {Number}
     */
    mutate: function mutate(translate) {
      for (var i2 = 0; i2 < TRANSFORMERS.length; i2++) {
        var transformer = TRANSFORMERS[i2];
        if (isFunction(transformer) && isFunction(transformer().modify)) {
          translate = transformer(Glide2, Components, Events).modify(translate);
        } else {
          warn("Transformer should be a function that returns an object with `modify()` method");
        }
      }
      return translate;
    }
  };
}
function Translate(Glide2, Components, Events) {
  var Translate2 = {
    /**
     * Sets value of translate on HTML element.
     *
     * @param {Number} value
     * @return {Void}
     */
    set: function set(value) {
      var transform = mutator(Glide2, Components).mutate(value);
      var translate3d = "translate3d(".concat(-1 * transform, "px, 0px, 0px)");
      Components.Html.wrapper.style.mozTransform = translate3d;
      Components.Html.wrapper.style.webkitTransform = translate3d;
      Components.Html.wrapper.style.transform = translate3d;
    },
    /**
     * Removes value of translate from HTML element.
     *
     * @return {Void}
     */
    remove: function remove() {
      Components.Html.wrapper.style.transform = "";
    },
    /**
     * @return {number}
     */
    getStartIndex: function getStartIndex() {
      var length = Components.Sizes.length;
      var index = Glide2.index;
      var perView = Glide2.settings.perView;
      if (Components.Run.isOffset(">") || Components.Run.isOffset("|>")) {
        return length + (index - perView);
      }
      return (index + perView) % length;
    },
    /**
     * @return {number}
     */
    getTravelDistance: function getTravelDistance() {
      var travelDistance = Components.Sizes.slideWidth * Glide2.settings.perView;
      if (Components.Run.isOffset(">") || Components.Run.isOffset("|>")) {
        return travelDistance * -1;
      }
      return travelDistance;
    }
  };
  Events.on("move", function(context) {
    if (!Glide2.isType("carousel") || !Components.Run.isOffset()) {
      return Translate2.set(context.movement);
    }
    Components.Transition.after(function() {
      Events.emit("translate.jump");
      Translate2.set(Components.Sizes.slideWidth * Glide2.index);
    });
    var startWidth = Components.Sizes.slideWidth * Components.Translate.getStartIndex();
    return Translate2.set(startWidth - Components.Translate.getTravelDistance());
  });
  Events.on("destroy", function() {
    Translate2.remove();
  });
  return Translate2;
}
function Transition(Glide2, Components, Events) {
  var disabled = false;
  var Transition2 = {
    /**
     * Composes string of the CSS transition.
     *
     * @param {String} property
     * @return {String}
     */
    compose: function compose(property) {
      var settings = Glide2.settings;
      if (!disabled) {
        return "".concat(property, " ").concat(this.duration, "ms ").concat(settings.animationTimingFunc);
      }
      return "".concat(property, " 0ms ").concat(settings.animationTimingFunc);
    },
    /**
     * Sets value of transition on HTML element.
     *
     * @param {String=} property
     * @return {Void}
     */
    set: function set() {
      var property = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      Components.Html.wrapper.style.transition = this.compose(property);
    },
    /**
     * Removes value of transition from HTML element.
     *
     * @return {Void}
     */
    remove: function remove() {
      Components.Html.wrapper.style.transition = "";
    },
    /**
     * Runs callback after animation.
     *
     * @param  {Function} callback
     * @return {Void}
     */
    after: function after(callback) {
      setTimeout(function() {
        callback();
      }, this.duration);
    },
    /**
     * Enable transition.
     *
     * @return {Void}
     */
    enable: function enable() {
      disabled = false;
      this.set();
    },
    /**
     * Disable transition.
     *
     * @return {Void}
     */
    disable: function disable() {
      disabled = true;
      this.set();
    }
  };
  define(Transition2, "duration", {
    /**
     * Gets duration of the transition based
     * on currently running animation type.
     *
     * @return {Number}
     */
    get: function get() {
      var settings = Glide2.settings;
      if (Glide2.isType("slider") && Components.Run.offset) {
        return settings.rewindDuration;
      }
      return settings.animationDuration;
    }
  });
  Events.on("move", function() {
    Transition2.set();
  });
  Events.on(["build.before", "resize", "translate.jump"], function() {
    Transition2.disable();
  });
  Events.on("run", function() {
    Transition2.enable();
  });
  Events.on("destroy", function() {
    Transition2.remove();
  });
  return Transition2;
}
var supportsPassive = false;
try {
  var opts = Object.defineProperty({}, "passive", {
    get: function get() {
      supportsPassive = true;
    }
  });
  window.addEventListener("testPassive", null, opts);
  window.removeEventListener("testPassive", null, opts);
} catch (e2) {
}
var supportsPassive$1 = supportsPassive;
var NAV_SELECTOR = '[data-glide-el="controls[nav]"]';
var CONTROLS_SELECTOR = '[data-glide-el^="controls"]';
var PREVIOUS_CONTROLS_SELECTOR = "".concat(CONTROLS_SELECTOR, ' [data-glide-dir*="<"]');
var NEXT_CONTROLS_SELECTOR = "".concat(CONTROLS_SELECTOR, ' [data-glide-dir*=">"]');
function controls(Glide2, Components, Events) {
  var Binder = new EventsBinder();
  var capture = supportsPassive$1 ? {
    passive: true
  } : false;
  var Controls = {
    /**
     * Inits arrows. Binds events listeners
     * to the arrows HTML elements.
     *
     * @return {Void}
     */
    mount: function mount2() {
      this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);
      this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);
      this._arrowControls = {
        previous: Components.Html.root.querySelectorAll(PREVIOUS_CONTROLS_SELECTOR),
        next: Components.Html.root.querySelectorAll(NEXT_CONTROLS_SELECTOR)
      };
      this.addBindings();
    },
    /**
     * Sets active class to current slide.
     *
     * @return {Void}
     */
    setActive: function setActive() {
      for (var i2 = 0; i2 < this._n.length; i2++) {
        this.addClass(this._n[i2].children);
      }
    },
    /**
     * Removes active class to current slide.
     *
     * @return {Void}
     */
    removeActive: function removeActive() {
      for (var i2 = 0; i2 < this._n.length; i2++) {
        this.removeClass(this._n[i2].children);
      }
    },
    /**
     * Toggles active class on items inside navigation.
     *
     * @param  {HTMLElement} controls
     * @return {Void}
     */
    addClass: function addClass(controls2) {
      var settings = Glide2.settings;
      var item = controls2[Glide2.index];
      if (!item) {
        return;
      }
      if (item) {
        item.classList.add(settings.classes.nav.active);
        siblings(item).forEach(function(sibling) {
          sibling.classList.remove(settings.classes.nav.active);
        });
      }
    },
    /**
     * Removes active class from active control.
     *
     * @param  {HTMLElement} controls
     * @return {Void}
     */
    removeClass: function removeClass(controls2) {
      var item = controls2[Glide2.index];
      if (item) {
        item.classList.remove(Glide2.settings.classes.nav.active);
      }
    },
    /**
     * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows
     */
    setArrowState: function setArrowState() {
      if (Glide2.settings.rewind) {
        return;
      }
      var next = Controls._arrowControls.next;
      var previous = Controls._arrowControls.previous;
      this.resetArrowState(next, previous);
      if (Glide2.index === 0) {
        this.disableArrow(previous);
      }
      if (Glide2.index === Components.Run.length) {
        this.disableArrow(next);
      }
    },
    /**
     * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements
     *
     * @param {NodeList[]} lists
     */
    resetArrowState: function resetArrowState() {
      var settings = Glide2.settings;
      for (var _len = arguments.length, lists = new Array(_len), _key = 0; _key < _len; _key++) {
        lists[_key] = arguments[_key];
      }
      lists.forEach(function(list) {
        toArray(list).forEach(function(element) {
          element.classList.remove(settings.classes.arrow.disabled);
        });
      });
    },
    /**
     * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements
     *
     * @param {NodeList[]} lists
     */
    disableArrow: function disableArrow() {
      var settings = Glide2.settings;
      for (var _len2 = arguments.length, lists = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        lists[_key2] = arguments[_key2];
      }
      lists.forEach(function(list) {
        toArray(list).forEach(function(element) {
          element.classList.add(settings.classes.arrow.disabled);
        });
      });
    },
    /**
     * Adds handles to the each group of controls.
     *
     * @return {Void}
     */
    addBindings: function addBindings() {
      for (var i2 = 0; i2 < this._c.length; i2++) {
        this.bind(this._c[i2].children);
      }
    },
    /**
     * Removes handles from the each group of controls.
     *
     * @return {Void}
     */
    removeBindings: function removeBindings() {
      for (var i2 = 0; i2 < this._c.length; i2++) {
        this.unbind(this._c[i2].children);
      }
    },
    /**
     * Binds events to arrows HTML elements.
     *
     * @param {HTMLCollection} elements
     * @return {Void}
     */
    bind: function bind(elements) {
      for (var i2 = 0; i2 < elements.length; i2++) {
        Binder.on("click", elements[i2], this.click);
        Binder.on("touchstart", elements[i2], this.click, capture);
      }
    },
    /**
     * Unbinds events binded to the arrows HTML elements.
     *
     * @param {HTMLCollection} elements
     * @return {Void}
     */
    unbind: function unbind(elements) {
      for (var i2 = 0; i2 < elements.length; i2++) {
        Binder.off(["click", "touchstart"], elements[i2]);
      }
    },
    /**
     * Handles `click` event on the arrows HTML elements.
     * Moves slider in direction given via the
     * `data-glide-dir` attribute.
     *
     * @param {Object} event
     * @return {void}
     */
    click: function click(event) {
      if (!supportsPassive$1 && event.type === "touchstart") {
        event.preventDefault();
      }
      var direction = event.currentTarget.getAttribute("data-glide-dir");
      Components.Run.make(Components.Direction.resolve(direction));
    }
  };
  define(Controls, "items", {
    /**
     * Gets collection of the controls HTML elements.
     *
     * @return {HTMLElement[]}
     */
    get: function get() {
      return Controls._c;
    }
  });
  Events.on(["mount.after", "move.after"], function() {
    Controls.setActive();
  });
  Events.on(["mount.after", "run"], function() {
    Controls.setArrowState();
  });
  Events.on("destroy", function() {
    Controls.removeBindings();
    Controls.removeActive();
    Binder.destroy();
  });
  return Controls;
}
var COMPONENTS = {
  Html,
  Translate,
  Transition,
  Direction,
  Peek,
  Sizes,
  Gaps,
  Move,
  Clones,
  Resize,
  Build,
  Run
};
var Glide = /* @__PURE__ */ function(_Core) {
  _inherits(Glide2, _Core);
  var _super = _createSuper(Glide2);
  function Glide2() {
    _classCallCheck(this, Glide2);
    return _super.apply(this, arguments);
  }
  _createClass(Glide2, [{
    key: "mount",
    value: function mount2() {
      var extensions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return _get(_getPrototypeOf(Glide2.prototype), "mount", this).call(this, Object.assign({}, COMPONENTS, extensions));
    }
  }]);
  return Glide2;
}(Glide$1);
class OSlider extends s {
  // eslint-disable-next-line no-useless-constructor
  constructor() {
    super();
  }
  firstUpdated() {
    const slider = this.renderRoot.querySelector(".glide");
    new Glide(slider).mount({ Controls: controls });
  }
  // eslint-disable-next-line class-methods-use-this
  render() {
    return y`
      <div class="glide o-slider">
        <div class="glide__track" data-glide-el="track">
          <ul class="glide__slides">
            <li class="glide-slide">
              <slot name="item1"></slot>
            </li>
            <li class="glide-slide">
              <slot name="item2"></slot>
            </li>
            <li class="glide-slide">
              <slot name="item3"></slot>
            </li>
          </ul>
        </div>
        <div class="glide__arrows" data-glide-el="controls">
          <button class="glide__arrow glide__arrow--left" data-glide-dir="<">
            prev
          </button>
          <button class="glide__arrow glide__arrow--right" data-glide-dir=">">
            next
          </button>
        </div>
      </div>
    `;
  }
}
__publicField(OSlider, "styles", i$1`
    .glide {
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    .glide * {
      box-sizing: inherit;
    }
    .glide__track {
      overflow: hidden;
    }
    .glide__slides {
      position: relative;
      width: 100%;
      list-style: none;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      transform-style: preserve-3d;
      touch-action: pan-Y;
      overflow: hidden;
      margin: 0;
      padding: 0;
      white-space: nowrap;
      display: flex;
      flex-wrap: nowrap;
      will-change: transform;
    }
    .glide__slides--dragging {
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .glide__slide {
      width: 100%;
      height: 100%;
      flex-shrink: 0;
      white-space: normal;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    .glide__slide a {
      -webkit-user-select: none;
      user-select: none;
      -webkit-user-drag: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    .glide__arrows {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .glide__bullets {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .glide--rtl {
      direction: rtl;
    }
    .o-slider {
      background-color: var(--color-light-accent);
      max-width: 800px;
    }
  `);
customElements.define("o-slider", OSlider);
