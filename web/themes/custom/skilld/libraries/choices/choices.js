/**
 * DO NOT EDIT THIS FILE.
 * It's generated automatically by 'yarn build' command.
 * @preserve
 * */
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
let choicesExports = {};
const choices = {
  get exports() {
    return choicesExports;
  },
  set exports(v) {
    choicesExports = v;
  },
};
/*! choices.js v10.2.0 | Â© 2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
(function (module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(window, function () {
    return (
      /** *** */
      (function () {
        const __webpack_modules__ = {
          /***/
          282:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.clearChoices = exports2.activateChoices = exports2.filterChoices = exports2.addChoice = void 0;
              const constants_1 = __webpack_require__2(883);
              const addChoice = function (_a) {
                const { value } = _a;
                const { label } = _a;
                const { id } = _a;
                const { groupId } = _a;
                const { disabled } = _a;
                const { elementId } = _a;
                const { customProperties } = _a;
                const { placeholder } = _a;
                const { keyCode } = _a;
                return {
                  type: constants_1.ACTION_TYPES.ADD_CHOICE,
                  value,
                  label,
                  id,
                  groupId,
                  disabled,
                  elementId,
                  customProperties,
                  placeholder,
                  keyCode,
                };
              };
              exports2.addChoice = addChoice;
              const filterChoices = function (results) {
                return {
                  type: constants_1.ACTION_TYPES.FILTER_CHOICES,
                  results,
                };
              };
              exports2.filterChoices = filterChoices;
              const activateChoices = function (active) {
                if (active === void 0) {
                  active = true;
                }
                return {
                  type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
                  active,
                };
              };
              exports2.activateChoices = activateChoices;
              const clearChoices = function () {
                return {
                  type: constants_1.ACTION_TYPES.CLEAR_CHOICES,
                };
              };
              exports2.clearChoices = clearChoices;
            },
          /***/
          783:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.addGroup = void 0;
              const constants_1 = __webpack_require__2(883);
              const addGroup = function (_a) {
                const { value } = _a;
                const { id } = _a;
                const { active } = _a;
                const { disabled } = _a;
                return {
                  type: constants_1.ACTION_TYPES.ADD_GROUP,
                  value,
                  id,
                  active,
                  disabled,
                };
              };
              exports2.addGroup = addGroup;
            },
          /***/
          464:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.highlightItem = exports2.removeItem = exports2.addItem = void 0;
              const constants_1 = __webpack_require__2(883);
              const addItem = function (_a) {
                const { value } = _a;
                const { label } = _a;
                const { id } = _a;
                const { choiceId } = _a;
                const { groupId } = _a;
                const { customProperties } = _a;
                const { placeholder } = _a;
                const { keyCode } = _a;
                return {
                  type: constants_1.ACTION_TYPES.ADD_ITEM,
                  value,
                  label,
                  id,
                  choiceId,
                  groupId,
                  customProperties,
                  placeholder,
                  keyCode,
                };
              };
              exports2.addItem = addItem;
              const removeItem = function (id, choiceId) {
                return {
                  type: constants_1.ACTION_TYPES.REMOVE_ITEM,
                  id,
                  choiceId,
                };
              };
              exports2.removeItem = removeItem;
              const highlightItem = function (id, highlighted) {
                return {
                  type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
                  id,
                  highlighted,
                };
              };
              exports2.highlightItem = highlightItem;
            },
          /***/
          137:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.setIsLoading = exports2.resetTo = exports2.clearAll = void 0;
              const constants_1 = __webpack_require__2(883);
              const clearAll = function () {
                return {
                  type: constants_1.ACTION_TYPES.CLEAR_ALL,
                };
              };
              exports2.clearAll = clearAll;
              const resetTo = function (state) {
                return {
                  type: constants_1.ACTION_TYPES.RESET_TO,
                  state,
                };
              };
              exports2.resetTo = resetTo;
              const setIsLoading = function (isLoading) {
                return {
                  type: constants_1.ACTION_TYPES.SET_IS_LOADING,
                  isLoading,
                };
              };
              exports2.setIsLoading = setIsLoading;
            },
          /***/
          373:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __spreadArray =
                (this && this.__spreadArray) ||
                function (to, from, pack) {
                  if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
              const __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule
                    ? mod
                    : {
                        default: mod,
                      };
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const deepmerge_1 = __importDefault(__webpack_require__2(996));
              const fuse_js_1 = __importDefault(__webpack_require__2(221));
              const choices_1 = __webpack_require__2(282);
              const groups_1 = __webpack_require__2(783);
              const items_1 = __webpack_require__2(464);
              const misc_1 = __webpack_require__2(137);
              const components_1 = __webpack_require__2(520);
              const constants_1 = __webpack_require__2(883);
              const defaults_1 = __webpack_require__2(789);
              const utils_1 = __webpack_require__2(799);
              const reducers_1 = __webpack_require__2(655);
              const store_1 = __importDefault(__webpack_require__2(744));
              const templates_1 = __importDefault(__webpack_require__2(686));
              const IS_IE11 = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;
              const USER_DEFAULTS = {};
              const Choices2 =
                /** @class */
                (function () {
                  function Choices3(element, userConfig) {
                    if (element === void 0) {
                      element = "[data-choice]";
                    }
                    if (userConfig === void 0) {
                      userConfig = {};
                    }
                    const _this = this;
                    if (userConfig.allowHTML === void 0) {
                      console.warn("Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.");
                    }
                    this.config = deepmerge_1.default.all(
                      [defaults_1.DEFAULT_CONFIG, Choices3.defaults.options, userConfig],
                      // When merging array configs, replace with a copy of the userConfig array,
                      // instead of concatenating with the default array
                      {
                        arrayMerge(_, sourceArray) {
                          return __spreadArray([], sourceArray, true);
                        },
                      },
                    );
                    const invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);
                    if (invalidConfigOptions.length) {
                      console.warn("Unknown config option(s) passed", invalidConfigOptions.join(", "));
                    }
                    const passedElement = typeof element === "string" ? document.querySelector(element) : element;
                    if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
                      throw TypeError("Expected one of the following types text|select-one|select-multiple");
                    }
                    this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
                    this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
                    this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
                    this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
                    this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;
                    if (!["auto", "always"].includes("".concat(this.config.renderSelectedChoices))) {
                      this.config.renderSelectedChoices = "auto";
                    }
                    if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== "function") {
                      const re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
                      this.config.addItemFilter = re.test.bind(re);
                    }
                    if (this._isTextElement) {
                      this.passedElement = new components_1.WrappedInput({
                        element: passedElement,
                        classNames: this.config.classNames,
                        delimiter: this.config.delimiter,
                      });
                    } else {
                      this.passedElement = new components_1.WrappedSelect({
                        element: passedElement,
                        classNames: this.config.classNames,
                        template(data) {
                          return _this._templates.option(data);
                        },
                      });
                    }
                    this.initialised = false;
                    this._store = new store_1.default();
                    this._initialState = reducers_1.defaultState;
                    this._currentState = reducers_1.defaultState;
                    this._prevState = reducers_1.defaultState;
                    this._currentValue = "";
                    this._canSearch = !!this.config.searchEnabled;
                    this._isScrollingOnIe = false;
                    this._highlightPosition = 0;
                    this._wasTap = true;
                    this._placeholderValue = this._generatePlaceholderValue();
                    this._baseId = (0, utils_1.generateId)(this.passedElement.element, "choices-");
                    this._direction = this.passedElement.dir;
                    if (!this._direction) {
                      const elementDirection = window.getComputedStyle(this.passedElement.element).direction;
                      const documentDirection = window.getComputedStyle(document.documentElement).direction;
                      if (elementDirection !== documentDirection) {
                        this._direction = elementDirection;
                      }
                    }
                    this._idNames = {
                      itemChoice: "item-choice",
                    };
                    if (this._isSelectElement) {
                      this._presetGroups = this.passedElement.optionGroups;
                      this._presetOptions = this.passedElement.options;
                    }
                    this._presetChoices = this.config.choices;
                    this._presetItems = this.config.items;
                    if (this.passedElement.value && this._isTextElement) {
                      const splitValues = this.passedElement.value.split(this.config.delimiter);
                      this._presetItems = this._presetItems.concat(splitValues);
                    }
                    if (this.passedElement.options) {
                      this.passedElement.options.forEach(function (option) {
                        _this._presetChoices.push({
                          value: option.value,
                          label: option.innerHTML,
                          selected: !!option.selected,
                          disabled: option.disabled || option.parentNode.disabled,
                          placeholder: option.value === "" || option.hasAttribute("placeholder"),
                          customProperties: (0, utils_1.parseCustomProperties)(option.dataset.customProperties),
                        });
                      });
                    }
                    this._render = this._render.bind(this);
                    this._onFocus = this._onFocus.bind(this);
                    this._onBlur = this._onBlur.bind(this);
                    this._onKeyUp = this._onKeyUp.bind(this);
                    this._onKeyDown = this._onKeyDown.bind(this);
                    this._onClick = this._onClick.bind(this);
                    this._onTouchMove = this._onTouchMove.bind(this);
                    this._onTouchEnd = this._onTouchEnd.bind(this);
                    this._onMouseDown = this._onMouseDown.bind(this);
                    this._onMouseOver = this._onMouseOver.bind(this);
                    this._onFormReset = this._onFormReset.bind(this);
                    this._onSelectKey = this._onSelectKey.bind(this);
                    this._onEnterKey = this._onEnterKey.bind(this);
                    this._onEscapeKey = this._onEscapeKey.bind(this);
                    this._onDirectionKey = this._onDirectionKey.bind(this);
                    this._onDeleteKey = this._onDeleteKey.bind(this);
                    if (this.passedElement.isActive) {
                      if (!this.config.silent) {
                        console.warn("Trying to initialise Choices on element already initialised", {
                          element,
                        });
                      }
                      this.initialised = true;
                      return;
                    }
                    this.init();
                  }
                  Object.defineProperty(Choices3, "defaults", {
                    get() {
                      return Object.preventExtensions({
                        get options() {
                          return USER_DEFAULTS;
                        },
                        get templates() {
                          return templates_1.default;
                        },
                      });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Choices3.prototype.init = function () {
                    if (this.initialised) {
                      return;
                    }
                    this._createTemplates();
                    this._createElements();
                    this._createStructure();
                    this._store.subscribe(this._render);
                    this._render();
                    this._addEventListeners();
                    const shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute("disabled");
                    if (shouldDisable) {
                      this.disable();
                    }
                    this.initialised = true;
                    const { callbackOnInit } = this.config;
                    if (callbackOnInit && typeof callbackOnInit === "function") {
                      callbackOnInit.call(this);
                    }
                  };
                  Choices3.prototype.destroy = function () {
                    if (!this.initialised) {
                      return;
                    }
                    this._removeEventListeners();
                    this.passedElement.reveal();
                    this.containerOuter.unwrap(this.passedElement.element);
                    this.clearStore();
                    if (this._isSelectElement) {
                      this.passedElement.options = this._presetOptions;
                    }
                    this._templates = templates_1.default;
                    this.initialised = false;
                  };
                  Choices3.prototype.enable = function () {
                    if (this.passedElement.isDisabled) {
                      this.passedElement.enable();
                    }
                    if (this.containerOuter.isDisabled) {
                      this._addEventListeners();
                      this.input.enable();
                      this.containerOuter.enable();
                    }
                    return this;
                  };
                  Choices3.prototype.disable = function () {
                    if (!this.passedElement.isDisabled) {
                      this.passedElement.disable();
                    }
                    if (!this.containerOuter.isDisabled) {
                      this._removeEventListeners();
                      this.input.disable();
                      this.containerOuter.disable();
                    }
                    return this;
                  };
                  Choices3.prototype.highlightItem = function (item, runEvent) {
                    if (runEvent === void 0) {
                      runEvent = true;
                    }
                    if (!item || !item.id) {
                      return this;
                    }
                    const { id } = item;
                    const _a = item.groupId;
                    const groupId = _a === void 0 ? -1 : _a;
                    const _b = item.value;
                    const value = _b === void 0 ? "" : _b;
                    const _c = item.label;
                    const label = _c === void 0 ? "" : _c;
                    const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                    this._store.dispatch((0, items_1.highlightItem)(id, true));
                    if (runEvent) {
                      this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                        id,
                        value,
                        label,
                        groupValue: group && group.value ? group.value : null,
                      });
                    }
                    return this;
                  };
                  Choices3.prototype.unhighlightItem = function (item) {
                    if (!item || !item.id) {
                      return this;
                    }
                    const { id } = item;
                    const _a = item.groupId;
                    const groupId = _a === void 0 ? -1 : _a;
                    const _b = item.value;
                    const value = _b === void 0 ? "" : _b;
                    const _c = item.label;
                    const label = _c === void 0 ? "" : _c;
                    const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                    this._store.dispatch((0, items_1.highlightItem)(id, false));
                    this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                      id,
                      value,
                      label,
                      groupValue: group && group.value ? group.value : null,
                    });
                    return this;
                  };
                  Choices3.prototype.highlightAll = function () {
                    const _this = this;
                    this._store.items.forEach(function (item) {
                      return _this.highlightItem(item);
                    });
                    return this;
                  };
                  Choices3.prototype.unhighlightAll = function () {
                    const _this = this;
                    this._store.items.forEach(function (item) {
                      return _this.unhighlightItem(item);
                    });
                    return this;
                  };
                  Choices3.prototype.removeActiveItemsByValue = function (value) {
                    const _this = this;
                    this._store.activeItems
                      .filter(function (item) {
                        return item.value === value;
                      })
                      .forEach(function (item) {
                        return _this._removeItem(item);
                      });
                    return this;
                  };
                  Choices3.prototype.removeActiveItems = function (excludedId) {
                    const _this = this;
                    this._store.activeItems
                      .filter(function (_a) {
                        const { id } = _a;
                        return id !== excludedId;
                      })
                      .forEach(function (item) {
                        return _this._removeItem(item);
                      });
                    return this;
                  };
                  Choices3.prototype.removeHighlightedItems = function (runEvent) {
                    const _this = this;
                    if (runEvent === void 0) {
                      runEvent = false;
                    }
                    this._store.highlightedActiveItems.forEach(function (item) {
                      _this._removeItem(item);
                      if (runEvent) {
                        _this._triggerChange(item.value);
                      }
                    });
                    return this;
                  };
                  Choices3.prototype.showDropdown = function (preventInputFocus) {
                    const _this = this;
                    if (this.dropdown.isActive) {
                      return this;
                    }
                    requestAnimationFrame(function () {
                      _this.dropdown.show();
                      _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);
                      if (!preventInputFocus && _this._canSearch) {
                        _this.input.focus();
                      }
                      _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
                    });
                    return this;
                  };
                  Choices3.prototype.hideDropdown = function (preventInputBlur) {
                    const _this = this;
                    if (!this.dropdown.isActive) {
                      return this;
                    }
                    requestAnimationFrame(function () {
                      _this.dropdown.hide();
                      _this.containerOuter.close();
                      if (!preventInputBlur && _this._canSearch) {
                        _this.input.removeActiveDescendant();
                        _this.input.blur();
                      }
                      _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
                    });
                    return this;
                  };
                  Choices3.prototype.getValue = function (valueOnly) {
                    if (valueOnly === void 0) {
                      valueOnly = false;
                    }
                    const values = this._store.activeItems.reduce(function (selectedItems, item) {
                      const itemValue = valueOnly ? item.value : item;
                      selectedItems.push(itemValue);
                      return selectedItems;
                    }, []);
                    return this._isSelectOneElement ? values[0] : values;
                  };
                  Choices3.prototype.setValue = function (items) {
                    const _this = this;
                    if (!this.initialised) {
                      return this;
                    }
                    items.forEach(function (value) {
                      return _this._setChoiceOrItem(value);
                    });
                    return this;
                  };
                  Choices3.prototype.setChoiceByValue = function (value) {
                    const _this = this;
                    if (!this.initialised || this._isTextElement) {
                      return this;
                    }
                    const choiceValue = Array.isArray(value) ? value : [value];
                    choiceValue.forEach(function (val) {
                      return _this._findAndSelectChoiceByValue(val);
                    });
                    return this;
                  };
                  Choices3.prototype.setChoices = function (choicesArrayOrFetcher, value, label, replaceChoices) {
                    const _this = this;
                    if (choicesArrayOrFetcher === void 0) {
                      choicesArrayOrFetcher = [];
                    }
                    if (value === void 0) {
                      value = "value";
                    }
                    if (label === void 0) {
                      label = "label";
                    }
                    if (replaceChoices === void 0) {
                      replaceChoices = false;
                    }
                    if (!this.initialised) {
                      throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
                    }
                    if (!this._isSelectElement) {
                      throw new TypeError("setChoices can't be used with INPUT based Choices");
                    }
                    if (typeof value !== "string" || !value) {
                      throw new TypeError("value parameter must be a name of 'value' field in passed objects");
                    }
                    if (replaceChoices) {
                      this.clearChoices();
                    }
                    if (typeof choicesArrayOrFetcher === "function") {
                      const fetcher_1 = choicesArrayOrFetcher(this);
                      if (typeof Promise === "function" && fetcher_1 instanceof Promise) {
                        return new Promise(function (resolve) {
                          return requestAnimationFrame(resolve);
                        })
                          .then(function () {
                            return _this._handleLoadingState(true);
                          })
                          .then(function () {
                            return fetcher_1;
                          })
                          .then(function (data) {
                            return _this.setChoices(data, value, label, replaceChoices);
                          })
                          .catch(function (err) {
                            if (!_this.config.silent) {
                              console.error(err);
                            }
                          })
                          .then(function () {
                            return _this._handleLoadingState(false);
                          })
                          .then(function () {
                            return _this;
                          });
                      }
                      if (!Array.isArray(fetcher_1)) {
                        throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
                      }
                      return this.setChoices(fetcher_1, value, label, false);
                    }
                    if (!Array.isArray(choicesArrayOrFetcher)) {
                      throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
                    }
                    this.containerOuter.removeLoadingState();
                    this._startLoading();
                    choicesArrayOrFetcher.forEach(function (groupOrChoice) {
                      if (groupOrChoice.choices) {
                        _this._addGroup({
                          id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
                          group: groupOrChoice,
                          valueKey: value,
                          labelKey: label,
                        });
                      } else {
                        const choice = groupOrChoice;
                        _this._addChoice({
                          value: choice[value],
                          label: choice[label],
                          isSelected: !!choice.selected,
                          isDisabled: !!choice.disabled,
                          placeholder: !!choice.placeholder,
                          customProperties: choice.customProperties,
                        });
                      }
                    });
                    this._stopLoading();
                    return this;
                  };
                  Choices3.prototype.clearChoices = function () {
                    this._store.dispatch((0, choices_1.clearChoices)());
                    return this;
                  };
                  Choices3.prototype.clearStore = function () {
                    this._store.dispatch((0, misc_1.clearAll)());
                    return this;
                  };
                  Choices3.prototype.clearInput = function () {
                    const shouldSetInputWidth = !this._isSelectOneElement;
                    this.input.clear(shouldSetInputWidth);
                    if (!this._isTextElement && this._canSearch) {
                      this._isSearching = false;
                      this._store.dispatch((0, choices_1.activateChoices)(true));
                    }
                    return this;
                  };
                  Choices3.prototype._render = function () {
                    if (this._store.isLoading()) {
                      return;
                    }
                    this._currentState = this._store.state;
                    const stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
                    const shouldRenderChoices = this._isSelectElement;
                    const shouldRenderItems = this._currentState.items !== this._prevState.items;
                    if (!stateChanged) {
                      return;
                    }
                    if (shouldRenderChoices) {
                      this._renderChoices();
                    }
                    if (shouldRenderItems) {
                      this._renderItems();
                    }
                    this._prevState = this._currentState;
                  };
                  Choices3.prototype._renderChoices = function () {
                    const _this = this;
                    const _a = this._store;
                    const { activeGroups } = _a;
                    const { activeChoices } = _a;
                    let choiceListFragment = document.createDocumentFragment();
                    this.choiceList.clear();
                    if (this.config.resetScrollPosition) {
                      requestAnimationFrame(function () {
                        return _this.choiceList.scrollToTop();
                      });
                    }
                    if (activeGroups.length >= 1 && !this._isSearching) {
                      const activePlaceholders = activeChoices.filter(function (activeChoice) {
                        return activeChoice.placeholder === true && activeChoice.groupId === -1;
                      });
                      if (activePlaceholders.length >= 1) {
                        choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                      }
                      choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
                    } else if (activeChoices.length >= 1) {
                      choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
                    }
                    if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
                      const { activeItems } = this._store;
                      const canAddItem = this._canAddItem(activeItems, this.input.value);
                      if (canAddItem.response) {
                        this.choiceList.append(choiceListFragment);
                        this._highlightChoice();
                      } else {
                        var notice = this._getTemplate("notice", canAddItem.notice);
                        this.choiceList.append(notice);
                      }
                    } else {
                      let dropdownItem = void 0;
                      var notice = void 0;
                      if (this._isSearching) {
                        notice = typeof this.config.noResultsText === "function" ? this.config.noResultsText() : this.config.noResultsText;
                        dropdownItem = this._getTemplate("notice", notice, "no-results");
                      } else {
                        notice = typeof this.config.noChoicesText === "function" ? this.config.noChoicesText() : this.config.noChoicesText;
                        dropdownItem = this._getTemplate("notice", notice, "no-choices");
                      }
                      this.choiceList.append(dropdownItem);
                    }
                  };
                  Choices3.prototype._renderItems = function () {
                    const activeItems = this._store.activeItems || [];
                    this.itemList.clear();
                    const itemListFragment = this._createItemsFragment(activeItems);
                    if (itemListFragment.childNodes) {
                      this.itemList.append(itemListFragment);
                    }
                  };
                  Choices3.prototype._createGroupsFragment = function (groups, choices2, fragment) {
                    const _this = this;
                    if (fragment === void 0) {
                      fragment = document.createDocumentFragment();
                    }
                    const getGroupChoices = function (group) {
                      return choices2.filter(function (choice) {
                        if (_this._isSelectOneElement) {
                          return choice.groupId === group.id;
                        }
                        return choice.groupId === group.id && (_this.config.renderSelectedChoices === "always" || !choice.selected);
                      });
                    };
                    if (this.config.shouldSort) {
                      groups.sort(this.config.sorter);
                    }
                    groups.forEach(function (group) {
                      const groupChoices = getGroupChoices(group);
                      if (groupChoices.length >= 1) {
                        const dropdownGroup = _this._getTemplate("choiceGroup", group);
                        fragment.appendChild(dropdownGroup);
                        _this._createChoicesFragment(groupChoices, fragment, true);
                      }
                    });
                    return fragment;
                  };
                  Choices3.prototype._createChoicesFragment = function (choices2, fragment, withinGroup) {
                    const _this = this;
                    if (fragment === void 0) {
                      fragment = document.createDocumentFragment();
                    }
                    if (withinGroup === void 0) {
                      withinGroup = false;
                    }
                    const _a = this.config;
                    const { renderSelectedChoices } = _a;
                    const { searchResultLimit } = _a;
                    const { renderChoiceLimit } = _a;
                    const filter = this._isSearching ? utils_1.sortByScore : this.config.sorter;
                    const appendChoice = function (choice) {
                      const shouldRender = renderSelectedChoices === "auto" ? _this._isSelectOneElement || !choice.selected : true;
                      if (shouldRender) {
                        const dropdownItem = _this._getTemplate("choice", choice, _this.config.itemSelectText);
                        fragment.appendChild(dropdownItem);
                      }
                    };
                    let rendererableChoices = choices2;
                    if (renderSelectedChoices === "auto" && !this._isSelectOneElement) {
                      rendererableChoices = choices2.filter(function (choice) {
                        return !choice.selected;
                      });
                    }
                    const _b = rendererableChoices.reduce(
                      function (acc, choice) {
                        if (choice.placeholder) {
                          acc.placeholderChoices.push(choice);
                        } else {
                          acc.normalChoices.push(choice);
                        }
                        return acc;
                      },
                      {
                        placeholderChoices: [],
                        normalChoices: [],
                      },
                    );
                    const { placeholderChoices } = _b;
                    const { normalChoices } = _b;
                    if (this.config.shouldSort || this._isSearching) {
                      normalChoices.sort(filter);
                    }
                    let choiceLimit = rendererableChoices.length;
                    const sortedChoices = this._isSelectOneElement ? __spreadArray(__spreadArray([], placeholderChoices, true), normalChoices, true) : normalChoices;
                    if (this._isSearching) {
                      choiceLimit = searchResultLimit;
                    } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                      choiceLimit = renderChoiceLimit;
                    }
                    for (let i = 0; i < choiceLimit; i += 1) {
                      if (sortedChoices[i]) {
                        appendChoice(sortedChoices[i]);
                      }
                    }
                    return fragment;
                  };
                  Choices3.prototype._createItemsFragment = function (items, fragment) {
                    const _this = this;
                    if (fragment === void 0) {
                      fragment = document.createDocumentFragment();
                    }
                    const _a = this.config;
                    const { shouldSortItems } = _a;
                    const { sorter } = _a;
                    const { removeItemButton } = _a;
                    if (shouldSortItems && !this._isSelectOneElement) {
                      items.sort(sorter);
                    }
                    if (this._isTextElement) {
                      this.passedElement.value = items
                        .map(function (_a2) {
                          const { value } = _a2;
                          return value;
                        })
                        .join(this.config.delimiter);
                    } else {
                      this.passedElement.options = items;
                    }
                    const addItemToFragment = function (item) {
                      const listItem = _this._getTemplate("item", item, removeItemButton);
                      fragment.appendChild(listItem);
                    };
                    items.forEach(addItemToFragment);
                    return fragment;
                  };
                  Choices3.prototype._triggerChange = function (value) {
                    if (value === void 0 || value === null) {
                      return;
                    }
                    this.passedElement.triggerEvent(constants_1.EVENTS.change, {
                      value,
                    });
                  };
                  Choices3.prototype._selectPlaceholderChoice = function (placeholderChoice) {
                    this._addItem({
                      value: placeholderChoice.value,
                      label: placeholderChoice.label,
                      choiceId: placeholderChoice.id,
                      groupId: placeholderChoice.groupId,
                      placeholder: placeholderChoice.placeholder,
                    });
                    this._triggerChange(placeholderChoice.value);
                  };
                  Choices3.prototype._handleButtonAction = function (activeItems, element) {
                    if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
                      return;
                    }
                    const itemId = element.parentNode && element.parentNode.dataset.id;
                    const itemToRemove =
                      itemId &&
                      activeItems.find(function (item) {
                        return item.id === parseInt(itemId, 10);
                      });
                    if (!itemToRemove) {
                      return;
                    }
                    this._removeItem(itemToRemove);
                    this._triggerChange(itemToRemove.value);
                    if (this._isSelectOneElement && this._store.placeholderChoice) {
                      this._selectPlaceholderChoice(this._store.placeholderChoice);
                    }
                  };
                  Choices3.prototype._handleItemAction = function (activeItems, element, hasShiftKey) {
                    const _this = this;
                    if (hasShiftKey === void 0) {
                      hasShiftKey = false;
                    }
                    if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
                      return;
                    }
                    const passedId = element.dataset.id;
                    activeItems.forEach(function (item) {
                      if (item.id === parseInt("".concat(passedId), 10) && !item.highlighted) {
                        _this.highlightItem(item);
                      } else if (!hasShiftKey && item.highlighted) {
                        _this.unhighlightItem(item);
                      }
                    });
                    this.input.focus();
                  };
                  Choices3.prototype._handleChoiceAction = function (activeItems, element) {
                    if (!activeItems || !element) {
                      return;
                    }
                    const { id } = element.dataset;
                    const choice = id && this._store.getChoiceById(id);
                    if (!choice) {
                      return;
                    }
                    const passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : void 0;
                    const hasActiveDropdown = this.dropdown.isActive;
                    choice.keyCode = passedKeyCode;
                    this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
                      choice,
                    });
                    if (!choice.selected && !choice.disabled) {
                      const canAddItem = this._canAddItem(activeItems, choice.value);
                      if (canAddItem.response) {
                        this._addItem({
                          value: choice.value,
                          label: choice.label,
                          choiceId: choice.id,
                          groupId: choice.groupId,
                          customProperties: choice.customProperties,
                          placeholder: choice.placeholder,
                          keyCode: choice.keyCode,
                        });
                        this._triggerChange(choice.value);
                      }
                    }
                    this.clearInput();
                    if (hasActiveDropdown && this._isSelectOneElement) {
                      this.hideDropdown(true);
                      this.containerOuter.focus();
                    }
                  };
                  Choices3.prototype._handleBackspace = function (activeItems) {
                    if (!this.config.removeItems || !activeItems) {
                      return;
                    }
                    const lastItem = activeItems[activeItems.length - 1];
                    const hasHighlightedItems = activeItems.some(function (item) {
                      return item.highlighted;
                    });
                    if (this.config.editItems && !hasHighlightedItems && lastItem) {
                      this.input.value = lastItem.value;
                      this.input.setWidth();
                      this._removeItem(lastItem);
                      this._triggerChange(lastItem.value);
                    } else {
                      if (!hasHighlightedItems) {
                        this.highlightItem(lastItem, false);
                      }
                      this.removeHighlightedItems(true);
                    }
                  };
                  Choices3.prototype._startLoading = function () {
                    this._store.dispatch((0, misc_1.setIsLoading)(true));
                  };
                  Choices3.prototype._stopLoading = function () {
                    this._store.dispatch((0, misc_1.setIsLoading)(false));
                  };
                  Choices3.prototype._handleLoadingState = function (setLoading) {
                    if (setLoading === void 0) {
                      setLoading = true;
                    }
                    let placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
                    if (setLoading) {
                      this.disable();
                      this.containerOuter.addLoadingState();
                      if (this._isSelectOneElement) {
                        if (!placeholderItem) {
                          placeholderItem = this._getTemplate("placeholder", this.config.loadingText);
                          if (placeholderItem) {
                            this.itemList.append(placeholderItem);
                          }
                        } else {
                          placeholderItem.innerHTML = this.config.loadingText;
                        }
                      } else {
                        this.input.placeholder = this.config.loadingText;
                      }
                    } else {
                      this.enable();
                      this.containerOuter.removeLoadingState();
                      if (this._isSelectOneElement) {
                        if (placeholderItem) {
                          placeholderItem.innerHTML = this._placeholderValue || "";
                        }
                      } else {
                        this.input.placeholder = this._placeholderValue || "";
                      }
                    }
                  };
                  Choices3.prototype._handleSearch = function (value) {
                    if (!this.input.isFocussed) {
                      return;
                    }
                    const choices2 = this._store.choices;
                    const _a = this.config;
                    const { searchFloor } = _a;
                    const { searchChoices } = _a;
                    const hasUnactiveChoices = choices2.some(function (option) {
                      return !option.active;
                    });
                    if (value !== null && typeof value !== "undefined" && value.length >= searchFloor) {
                      const resultCount = searchChoices ? this._searchChoices(value) : 0;
                      this.passedElement.triggerEvent(constants_1.EVENTS.search, {
                        value,
                        resultCount,
                      });
                    } else if (hasUnactiveChoices) {
                      this._isSearching = false;
                      this._store.dispatch((0, choices_1.activateChoices)(true));
                    }
                  };
                  Choices3.prototype._canAddItem = function (activeItems, value) {
                    let canAddItem = true;
                    let notice = typeof this.config.addItemText === "function" ? this.config.addItemText(value) : this.config.addItemText;
                    if (!this._isSelectOneElement) {
                      const isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value);
                      if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
                        canAddItem = false;
                        notice = typeof this.config.maxItemText === "function" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
                      }
                      if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
                        canAddItem = false;
                        notice = typeof this.config.uniqueItemText === "function" ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
                      }
                      if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === "function" && !this.config.addItemFilter(value)) {
                        canAddItem = false;
                        notice = typeof this.config.customAddItemText === "function" ? this.config.customAddItemText(value) : this.config.customAddItemText;
                      }
                    }
                    return {
                      response: canAddItem,
                      notice,
                    };
                  };
                  Choices3.prototype._searchChoices = function (value) {
                    const newValue = typeof value === "string" ? value.trim() : value;
                    const currentValue = typeof this._currentValue === "string" ? this._currentValue.trim() : this._currentValue;
                    if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
                      return 0;
                    }
                    const haystack = this._store.searchableChoices;
                    const needle = newValue;
                    const options = Object.assign(this.config.fuseOptions, {
                      keys: __spreadArray([], this.config.searchFields, true),
                      includeMatches: true,
                    });
                    const fuse = new fuse_js_1.default(haystack, options);
                    const results = fuse.search(needle);
                    this._currentValue = newValue;
                    this._highlightPosition = 0;
                    this._isSearching = true;
                    this._store.dispatch((0, choices_1.filterChoices)(results));
                    return results.length;
                  };
                  Choices3.prototype._addEventListeners = function () {
                    const { documentElement } = document;
                    documentElement.addEventListener("touchend", this._onTouchEnd, true);
                    this.containerOuter.element.addEventListener("keydown", this._onKeyDown, true);
                    this.containerOuter.element.addEventListener("mousedown", this._onMouseDown, true);
                    documentElement.addEventListener("click", this._onClick, {
                      passive: true,
                    });
                    documentElement.addEventListener("touchmove", this._onTouchMove, {
                      passive: true,
                    });
                    this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
                      passive: true,
                    });
                    if (this._isSelectOneElement) {
                      this.containerOuter.element.addEventListener("focus", this._onFocus, {
                        passive: true,
                      });
                      this.containerOuter.element.addEventListener("blur", this._onBlur, {
                        passive: true,
                      });
                    }
                    this.input.element.addEventListener("keyup", this._onKeyUp, {
                      passive: true,
                    });
                    this.input.element.addEventListener("focus", this._onFocus, {
                      passive: true,
                    });
                    this.input.element.addEventListener("blur", this._onBlur, {
                      passive: true,
                    });
                    if (this.input.element.form) {
                      this.input.element.form.addEventListener("reset", this._onFormReset, {
                        passive: true,
                      });
                    }
                    this.input.addEventListeners();
                  };
                  Choices3.prototype._removeEventListeners = function () {
                    const { documentElement } = document;
                    documentElement.removeEventListener("touchend", this._onTouchEnd, true);
                    this.containerOuter.element.removeEventListener("keydown", this._onKeyDown, true);
                    this.containerOuter.element.removeEventListener("mousedown", this._onMouseDown, true);
                    documentElement.removeEventListener("click", this._onClick);
                    documentElement.removeEventListener("touchmove", this._onTouchMove);
                    this.dropdown.element.removeEventListener("mouseover", this._onMouseOver);
                    if (this._isSelectOneElement) {
                      this.containerOuter.element.removeEventListener("focus", this._onFocus);
                      this.containerOuter.element.removeEventListener("blur", this._onBlur);
                    }
                    this.input.element.removeEventListener("keyup", this._onKeyUp);
                    this.input.element.removeEventListener("focus", this._onFocus);
                    this.input.element.removeEventListener("blur", this._onBlur);
                    if (this.input.element.form) {
                      this.input.element.form.removeEventListener("reset", this._onFormReset);
                    }
                    this.input.removeEventListeners();
                  };
                  Choices3.prototype._onKeyDown = function (event) {
                    const { keyCode } = event;
                    const { activeItems } = this._store;
                    const hasFocusedInput = this.input.isFocussed;
                    const hasActiveDropdown = this.dropdown.isActive;
                    const hasItems = this.itemList.hasChildren();
                    const keyString = String.fromCharCode(keyCode);
                    const wasPrintableChar = /[^\x00-\x1F]/.test(keyString);
                    const { BACK_KEY } = constants_1.KEY_CODES;
                    const { DELETE_KEY } = constants_1.KEY_CODES;
                    const { ENTER_KEY } = constants_1.KEY_CODES;
                    const { A_KEY } = constants_1.KEY_CODES;
                    const { ESC_KEY } = constants_1.KEY_CODES;
                    const { UP_KEY } = constants_1.KEY_CODES;
                    const { DOWN_KEY } = constants_1.KEY_CODES;
                    const { PAGE_UP_KEY } = constants_1.KEY_CODES;
                    const { PAGE_DOWN_KEY } = constants_1.KEY_CODES;
                    if (!this._isTextElement && !hasActiveDropdown && wasPrintableChar) {
                      this.showDropdown();
                      if (!this.input.isFocussed) {
                        this.input.value += event.key.toLowerCase();
                      }
                    }
                    switch (keyCode) {
                      case A_KEY:
                        return this._onSelectKey(event, hasItems);
                      case ENTER_KEY:
                        return this._onEnterKey(event, activeItems, hasActiveDropdown);
                      case ESC_KEY:
                        return this._onEscapeKey(hasActiveDropdown);
                      case UP_KEY:
                      case PAGE_UP_KEY:
                      case DOWN_KEY:
                      case PAGE_DOWN_KEY:
                        return this._onDirectionKey(event, hasActiveDropdown);
                      case DELETE_KEY:
                      case BACK_KEY:
                        return this._onDeleteKey(event, activeItems, hasFocusedInput);
                    }
                  };
                  Choices3.prototype._onKeyUp = function (_a) {
                    const { target } = _a;
                    const { keyCode } = _a;
                    const { value } = this.input;
                    const { activeItems } = this._store;
                    const canAddItem = this._canAddItem(activeItems, value);
                    const backKey = constants_1.KEY_CODES.BACK_KEY;
                    const deleteKey = constants_1.KEY_CODES.DELETE_KEY;
                    if (this._isTextElement) {
                      const canShowDropdownNotice = canAddItem.notice && value;
                      if (canShowDropdownNotice) {
                        const dropdownItem = this._getTemplate("notice", canAddItem.notice);
                        this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                        this.showDropdown(true);
                      } else {
                        this.hideDropdown(true);
                      }
                    } else {
                      const wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
                      const userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                      const canReactivateChoices = !this._isTextElement && this._isSearching;
                      const canSearch = this._canSearch && canAddItem.response;
                      if (userHasRemovedValue && canReactivateChoices) {
                        this._isSearching = false;
                        this._store.dispatch((0, choices_1.activateChoices)(true));
                      } else if (canSearch) {
                        this._handleSearch(this.input.rawValue);
                      }
                    }
                    this._canSearch = this.config.searchEnabled;
                  };
                  Choices3.prototype._onSelectKey = function (event, hasItems) {
                    const { ctrlKey } = event;
                    const { metaKey } = event;
                    const hasCtrlDownKeyPressed = ctrlKey || metaKey;
                    if (hasCtrlDownKeyPressed && hasItems) {
                      this._canSearch = false;
                      const shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
                      if (shouldHightlightAll) {
                        this.highlightAll();
                      }
                    }
                  };
                  Choices3.prototype._onEnterKey = function (event, activeItems, hasActiveDropdown) {
                    const { target } = event;
                    const enterKey = constants_1.KEY_CODES.ENTER_KEY;
                    const targetWasButton = target && target.hasAttribute("data-button");
                    if (this._isTextElement && target && target.value) {
                      const { value } = this.input;
                      const canAddItem = this._canAddItem(activeItems, value);
                      if (canAddItem.response) {
                        this.hideDropdown(true);
                        this._addItem({
                          value,
                        });
                        this._triggerChange(value);
                        this.clearInput();
                      }
                    }
                    if (targetWasButton) {
                      this._handleButtonAction(activeItems, target);
                      event.preventDefault();
                    }
                    if (hasActiveDropdown) {
                      const highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
                      if (highlightedChoice) {
                        if (activeItems[0]) {
                          activeItems[0].keyCode = enterKey;
                        }
                        this._handleChoiceAction(activeItems, highlightedChoice);
                      }
                      event.preventDefault();
                    } else if (this._isSelectOneElement) {
                      this.showDropdown();
                      event.preventDefault();
                    }
                  };
                  Choices3.prototype._onEscapeKey = function (hasActiveDropdown) {
                    if (hasActiveDropdown) {
                      this.hideDropdown(true);
                      this.containerOuter.focus();
                    }
                  };
                  Choices3.prototype._onDirectionKey = function (event, hasActiveDropdown) {
                    const { keyCode } = event;
                    const { metaKey } = event;
                    const downKey = constants_1.KEY_CODES.DOWN_KEY;
                    const pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY;
                    const pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                    if (hasActiveDropdown || this._isSelectOneElement) {
                      this.showDropdown();
                      this._canSearch = false;
                      const directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                      const skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                      const selectableChoiceIdentifier = "[data-choice-selectable]";
                      let nextEl = void 0;
                      if (skipKey) {
                        if (directionInt > 0) {
                          nextEl = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                        } else {
                          nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                        }
                      } else {
                        const currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
                        if (currentEl) {
                          nextEl = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
                        } else {
                          nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                        }
                      }
                      if (nextEl) {
                        if (!(0, utils_1.isScrolledIntoView)(nextEl, this.choiceList.element, directionInt)) {
                          this.choiceList.scrollToChildElement(nextEl, directionInt);
                        }
                        this._highlightChoice(nextEl);
                      }
                      event.preventDefault();
                    }
                  };
                  Choices3.prototype._onDeleteKey = function (event, activeItems, hasFocusedInput) {
                    const { target } = event;
                    if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
                      this._handleBackspace(activeItems);
                      event.preventDefault();
                    }
                  };
                  Choices3.prototype._onTouchMove = function () {
                    if (this._wasTap) {
                      this._wasTap = false;
                    }
                  };
                  Choices3.prototype._onTouchEnd = function (event) {
                    const { target } = event || event.touches[0];
                    const touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
                    if (touchWasWithinContainer) {
                      const containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
                      if (containerWasExactTarget) {
                        if (this._isTextElement) {
                          this.input.focus();
                        } else if (this._isSelectMultipleElement) {
                          this.showDropdown();
                        }
                      }
                      event.stopPropagation();
                    }
                    this._wasTap = true;
                  };
                  Choices3.prototype._onMouseDown = function (event) {
                    const { target } = event;
                    if (!(target instanceof HTMLElement)) {
                      return;
                    }
                    if (IS_IE11 && this.choiceList.element.contains(target)) {
                      const firstChoice = this.choiceList.element.firstElementChild;
                      const isOnScrollbar = this._direction === "ltr" ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
                      this._isScrollingOnIe = isOnScrollbar;
                    }
                    if (target === this.input.element) {
                      return;
                    }
                    const item = target.closest("[data-button],[data-item],[data-choice]");
                    if (item instanceof HTMLElement) {
                      const hasShiftKey = event.shiftKey;
                      const { activeItems } = this._store;
                      const { dataset } = item;
                      if ("button" in dataset) {
                        this._handleButtonAction(activeItems, item);
                      } else if ("item" in dataset) {
                        this._handleItemAction(activeItems, item, hasShiftKey);
                      } else if ("choice" in dataset) {
                        this._handleChoiceAction(activeItems, item);
                      }
                    }
                    event.preventDefault();
                  };
                  Choices3.prototype._onMouseOver = function (_a) {
                    const { target } = _a;
                    if (target instanceof HTMLElement && "choice" in target.dataset) {
                      this._highlightChoice(target);
                    }
                  };
                  Choices3.prototype._onClick = function (_a) {
                    const { target } = _a;
                    const clickWasWithinContainer = this.containerOuter.element.contains(target);
                    if (clickWasWithinContainer) {
                      if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                        if (this._isTextElement) {
                          if (document.activeElement !== this.input.element) {
                            this.input.focus();
                          }
                        } else {
                          this.showDropdown();
                          this.containerOuter.focus();
                        }
                      } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
                        this.hideDropdown();
                      }
                    } else {
                      const hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                      if (hasHighlightedItems) {
                        this.unhighlightAll();
                      }
                      this.containerOuter.removeFocusState();
                      this.hideDropdown(true);
                    }
                  };
                  Choices3.prototype._onFocus = function (_a) {
                    let _b;
                    const _this = this;
                    const { target } = _a;
                    const focusWasWithinContainer = target && this.containerOuter.element.contains(target);
                    if (!focusWasWithinContainer) {
                      return;
                    }
                    const focusActions =
                      ((_b = {}),
                      (_b[constants_1.TEXT_TYPE] = function () {
                        if (target === _this.input.element) {
                          _this.containerOuter.addFocusState();
                        }
                      }),
                      (_b[constants_1.SELECT_ONE_TYPE] = function () {
                        _this.containerOuter.addFocusState();
                        if (target === _this.input.element) {
                          _this.showDropdown(true);
                        }
                      }),
                      (_b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
                        if (target === _this.input.element) {
                          _this.showDropdown(true);
                          _this.containerOuter.addFocusState();
                        }
                      }),
                      _b);
                    focusActions[this.passedElement.element.type]();
                  };
                  Choices3.prototype._onBlur = function (_a) {
                    let _b;
                    const _this = this;
                    const { target } = _a;
                    const blurWasWithinContainer = target && this.containerOuter.element.contains(target);
                    if (blurWasWithinContainer && !this._isScrollingOnIe) {
                      const { activeItems } = this._store;
                      const hasHighlightedItems_1 = activeItems.some(function (item) {
                        return item.highlighted;
                      });
                      const blurActions =
                        ((_b = {}),
                        (_b[constants_1.TEXT_TYPE] = function () {
                          if (target === _this.input.element) {
                            _this.containerOuter.removeFocusState();
                            if (hasHighlightedItems_1) {
                              _this.unhighlightAll();
                            }
                            _this.hideDropdown(true);
                          }
                        }),
                        (_b[constants_1.SELECT_ONE_TYPE] = function () {
                          _this.containerOuter.removeFocusState();
                          if (target === _this.input.element || (target === _this.containerOuter.element && !_this._canSearch)) {
                            _this.hideDropdown(true);
                          }
                        }),
                        (_b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
                          if (target === _this.input.element) {
                            _this.containerOuter.removeFocusState();
                            _this.hideDropdown(true);
                            if (hasHighlightedItems_1) {
                              _this.unhighlightAll();
                            }
                          }
                        }),
                        _b);
                      blurActions[this.passedElement.element.type]();
                    } else {
                      this._isScrollingOnIe = false;
                      this.input.element.focus();
                    }
                  };
                  Choices3.prototype._onFormReset = function () {
                    this._store.dispatch((0, misc_1.resetTo)(this._initialState));
                  };
                  Choices3.prototype._highlightChoice = function (el) {
                    const _this = this;
                    if (el === void 0) {
                      el = null;
                    }
                    const choices2 = Array.from(this.dropdown.element.querySelectorAll("[data-choice-selectable]"));
                    if (!choices2.length) {
                      return;
                    }
                    let passedEl = el;
                    const highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
                    highlightedChoices.forEach(function (choice) {
                      choice.classList.remove(_this.config.classNames.highlightedState);
                      choice.setAttribute("aria-selected", "false");
                    });
                    if (passedEl) {
                      this._highlightPosition = choices2.indexOf(passedEl);
                    } else {
                      if (choices2.length > this._highlightPosition) {
                        passedEl = choices2[this._highlightPosition];
                      } else {
                        passedEl = choices2[choices2.length - 1];
                      }
                      if (!passedEl) {
                        passedEl = choices2[0];
                      }
                    }
                    passedEl.classList.add(this.config.classNames.highlightedState);
                    passedEl.setAttribute("aria-selected", "true");
                    this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
                      el: passedEl,
                    });
                    if (this.dropdown.isActive) {
                      this.input.setActiveDescendant(passedEl.id);
                      this.containerOuter.setActiveDescendant(passedEl.id);
                    }
                  };
                  Choices3.prototype._addItem = function (_a) {
                    const { value } = _a;
                    const _b = _a.label;
                    const label = _b === void 0 ? null : _b;
                    const _c = _a.choiceId;
                    const choiceId = _c === void 0 ? -1 : _c;
                    const _d = _a.groupId;
                    const groupId = _d === void 0 ? -1 : _d;
                    const _e = _a.customProperties;
                    const customProperties = _e === void 0 ? {} : _e;
                    const _f = _a.placeholder;
                    const placeholder = _f === void 0 ? false : _f;
                    const _g = _a.keyCode;
                    const keyCode = _g === void 0 ? -1 : _g;
                    let passedValue = typeof value === "string" ? value.trim() : value;
                    const { items } = this._store;
                    const passedLabel = label || passedValue;
                    const passedOptionId = choiceId || -1;
                    const group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                    const id = items ? items.length + 1 : 1;
                    if (this.config.prependValue) {
                      passedValue = this.config.prependValue + passedValue.toString();
                    }
                    if (this.config.appendValue) {
                      passedValue += this.config.appendValue.toString();
                    }
                    this._store.dispatch(
                      (0, items_1.addItem)({
                        value: passedValue,
                        label: passedLabel,
                        id,
                        choiceId: passedOptionId,
                        groupId,
                        customProperties,
                        placeholder,
                        keyCode,
                      }),
                    );
                    if (this._isSelectOneElement) {
                      this.removeActiveItems(id);
                    }
                    this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
                      id,
                      value: passedValue,
                      label: passedLabel,
                      customProperties,
                      groupValue: group && group.value ? group.value : null,
                      keyCode,
                    });
                  };
                  Choices3.prototype._removeItem = function (item) {
                    const { id } = item;
                    const { value } = item;
                    const { label } = item;
                    const { customProperties } = item;
                    const { choiceId } = item;
                    const { groupId } = item;
                    const group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
                    if (!id || !choiceId) {
                      return;
                    }
                    this._store.dispatch((0, items_1.removeItem)(id, choiceId));
                    this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
                      id,
                      value,
                      label,
                      customProperties,
                      groupValue: group && group.value ? group.value : null,
                    });
                  };
                  Choices3.prototype._addChoice = function (_a) {
                    const { value } = _a;
                    const _b = _a.label;
                    const label = _b === void 0 ? null : _b;
                    const _c = _a.isSelected;
                    const isSelected = _c === void 0 ? false : _c;
                    const _d = _a.isDisabled;
                    const isDisabled = _d === void 0 ? false : _d;
                    const _e = _a.groupId;
                    const groupId = _e === void 0 ? -1 : _e;
                    const _f = _a.customProperties;
                    const customProperties = _f === void 0 ? {} : _f;
                    const _g = _a.placeholder;
                    const placeholder = _g === void 0 ? false : _g;
                    const _h = _a.keyCode;
                    const keyCode = _h === void 0 ? -1 : _h;
                    if (typeof value === "undefined" || value === null) {
                      return;
                    }
                    const choices2 = this._store.choices;
                    const choiceLabel = label || value;
                    const choiceId = choices2 ? choices2.length + 1 : 1;
                    const choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);
                    this._store.dispatch(
                      (0, choices_1.addChoice)({
                        id: choiceId,
                        groupId,
                        elementId: choiceElementId,
                        value,
                        label: choiceLabel,
                        disabled: isDisabled,
                        customProperties,
                        placeholder,
                        keyCode,
                      }),
                    );
                    if (isSelected) {
                      this._addItem({
                        value,
                        label: choiceLabel,
                        choiceId,
                        customProperties,
                        placeholder,
                        keyCode,
                      });
                    }
                  };
                  Choices3.prototype._addGroup = function (_a) {
                    const _this = this;
                    const { group } = _a;
                    const { id } = _a;
                    const _b = _a.valueKey;
                    const valueKey = _b === void 0 ? "value" : _b;
                    const _c = _a.labelKey;
                    const labelKey = _c === void 0 ? "label" : _c;
                    const groupChoices = (0, utils_1.isType)("Object", group) ? group.choices : Array.from(group.getElementsByTagName("OPTION"));
                    const groupId = id || Math.floor(/* @__PURE__ */ new Date().valueOf() * Math.random());
                    const isDisabled = group.disabled ? group.disabled : false;
                    if (groupChoices) {
                      this._store.dispatch(
                        (0, groups_1.addGroup)({
                          value: group.label,
                          id: groupId,
                          active: true,
                          disabled: isDisabled,
                        }),
                      );
                      const addGroupChoices = function (choice) {
                        const isOptDisabled = choice.disabled || (choice.parentNode && choice.parentNode.disabled);
                        _this._addChoice({
                          value: choice[valueKey],
                          label: (0, utils_1.isType)("Object", choice) ? choice[labelKey] : choice.innerHTML,
                          isSelected: choice.selected,
                          isDisabled: isOptDisabled,
                          groupId,
                          customProperties: choice.customProperties,
                          placeholder: choice.placeholder,
                        });
                      };
                      groupChoices.forEach(addGroupChoices);
                    } else {
                      this._store.dispatch(
                        (0, groups_1.addGroup)({
                          value: group.label,
                          id: group.id,
                          active: false,
                          disabled: group.disabled,
                        }),
                      );
                    }
                  };
                  Choices3.prototype._getTemplate = function (template) {
                    let _a;
                    const args = [];
                    for (let _i = 1; _i < arguments.length; _i++) {
                      args[_i - 1] = arguments[_i];
                    }
                    return (_a = this._templates[template]).call.apply(_a, __spreadArray([this, this.config], args, false));
                  };
                  Choices3.prototype._createTemplates = function () {
                    const { callbackOnCreateTemplates } = this.config;
                    let userTemplates = {};
                    if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === "function") {
                      userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
                    }
                    this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
                  };
                  Choices3.prototype._createElements = function () {
                    this.containerOuter = new components_1.Container({
                      element: this._getTemplate("containerOuter", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                      position: this.config.position,
                    });
                    this.containerInner = new components_1.Container({
                      element: this._getTemplate("containerInner"),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                      position: this.config.position,
                    });
                    this.input = new components_1.Input({
                      element: this._getTemplate("input", this._placeholderValue),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                      preventPaste: !this.config.paste,
                    });
                    this.choiceList = new components_1.List({
                      element: this._getTemplate("choiceList", this._isSelectOneElement),
                    });
                    this.itemList = new components_1.List({
                      element: this._getTemplate("itemList", this._isSelectOneElement),
                    });
                    this.dropdown = new components_1.Dropdown({
                      element: this._getTemplate("dropdown"),
                      classNames: this.config.classNames,
                      type: this.passedElement.element.type,
                    });
                  };
                  Choices3.prototype._createStructure = function () {
                    this.passedElement.conceal();
                    this.containerInner.wrap(this.passedElement.element);
                    this.containerOuter.wrap(this.containerInner.element);
                    if (this._isSelectOneElement) {
                      this.input.placeholder = this.config.searchPlaceholderValue || "";
                    } else if (this._placeholderValue) {
                      this.input.placeholder = this._placeholderValue;
                      this.input.setWidth();
                    }
                    this.containerOuter.element.appendChild(this.containerInner.element);
                    this.containerOuter.element.appendChild(this.dropdown.element);
                    this.containerInner.element.appendChild(this.itemList.element);
                    if (!this._isTextElement) {
                      this.dropdown.element.appendChild(this.choiceList.element);
                    }
                    if (!this._isSelectOneElement) {
                      this.containerInner.element.appendChild(this.input.element);
                    } else if (this.config.searchEnabled) {
                      this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
                    }
                    if (this._isSelectElement) {
                      this._highlightPosition = 0;
                      this._isSearching = false;
                      this._startLoading();
                      if (this._presetGroups.length) {
                        this._addPredefinedGroups(this._presetGroups);
                      } else {
                        this._addPredefinedChoices(this._presetChoices);
                      }
                      this._stopLoading();
                    }
                    if (this._isTextElement) {
                      this._addPredefinedItems(this._presetItems);
                    }
                  };
                  Choices3.prototype._addPredefinedGroups = function (groups) {
                    const _this = this;
                    const placeholderChoice = this.passedElement.placeholderOption;
                    if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === "SELECT") {
                      this._addChoice({
                        value: placeholderChoice.value,
                        label: placeholderChoice.innerHTML,
                        isSelected: placeholderChoice.selected,
                        isDisabled: placeholderChoice.disabled,
                        placeholder: true,
                      });
                    }
                    groups.forEach(function (group) {
                      return _this._addGroup({
                        group,
                        id: group.id || null,
                      });
                    });
                  };
                  Choices3.prototype._addPredefinedChoices = function (choices2) {
                    const _this = this;
                    if (this.config.shouldSort) {
                      choices2.sort(this.config.sorter);
                    }
                    const hasSelectedChoice = choices2.some(function (choice) {
                      return choice.selected;
                    });
                    const firstEnabledChoiceIndex = choices2.findIndex(function (choice) {
                      return choice.disabled === void 0 || !choice.disabled;
                    });
                    choices2.forEach(function (choice, index) {
                      const _a = choice.value;
                      const value = _a === void 0 ? "" : _a;
                      const { label } = choice;
                      const { customProperties } = choice;
                      const { placeholder } = choice;
                      if (_this._isSelectElement) {
                        if (choice.choices) {
                          _this._addGroup({
                            group: choice,
                            id: choice.id || null,
                          });
                        } else {
                          const shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;
                          const isSelected = shouldPreselect ? true : choice.selected;
                          const isDisabled = choice.disabled;
                          _this._addChoice({
                            value,
                            label,
                            isSelected: !!isSelected,
                            isDisabled: !!isDisabled,
                            placeholder: !!placeholder,
                            customProperties,
                          });
                        }
                      } else {
                        _this._addChoice({
                          value,
                          label,
                          isSelected: !!choice.selected,
                          isDisabled: !!choice.disabled,
                          placeholder: !!choice.placeholder,
                          customProperties,
                        });
                      }
                    });
                  };
                  Choices3.prototype._addPredefinedItems = function (items) {
                    const _this = this;
                    items.forEach(function (item) {
                      if (typeof item === "object" && item.value) {
                        _this._addItem({
                          value: item.value,
                          label: item.label,
                          choiceId: item.id,
                          customProperties: item.customProperties,
                          placeholder: item.placeholder,
                        });
                      }
                      if (typeof item === "string") {
                        _this._addItem({
                          value: item,
                        });
                      }
                    });
                  };
                  Choices3.prototype._setChoiceOrItem = function (item) {
                    const _this = this;
                    const itemType = (0, utils_1.getType)(item).toLowerCase();
                    const handleType = {
                      object() {
                        if (!item.value) {
                          return;
                        }
                        if (!_this._isTextElement) {
                          _this._addChoice({
                            value: item.value,
                            label: item.label,
                            isSelected: true,
                            isDisabled: false,
                            customProperties: item.customProperties,
                            placeholder: item.placeholder,
                          });
                        } else {
                          _this._addItem({
                            value: item.value,
                            label: item.label,
                            choiceId: item.id,
                            customProperties: item.customProperties,
                            placeholder: item.placeholder,
                          });
                        }
                      },
                      string() {
                        if (!_this._isTextElement) {
                          _this._addChoice({
                            value: item,
                            label: item,
                            isSelected: true,
                            isDisabled: false,
                          });
                        } else {
                          _this._addItem({
                            value: item,
                          });
                        }
                      },
                    };
                    handleType[itemType]();
                  };
                  Choices3.prototype._findAndSelectChoiceByValue = function (value) {
                    const _this = this;
                    const choices2 = this._store.choices;
                    const foundChoice = choices2.find(function (choice) {
                      return _this.config.valueComparer(choice.value, value);
                    });
                    if (foundChoice && !foundChoice.selected) {
                      this._addItem({
                        value: foundChoice.value,
                        label: foundChoice.label,
                        choiceId: foundChoice.id,
                        groupId: foundChoice.groupId,
                        customProperties: foundChoice.customProperties,
                        placeholder: foundChoice.placeholder,
                        keyCode: foundChoice.keyCode,
                      });
                    }
                  };
                  Choices3.prototype._generatePlaceholderValue = function () {
                    if (this._isSelectElement && this.passedElement.placeholderOption) {
                      const { placeholderOption } = this.passedElement;
                      return placeholderOption ? placeholderOption.text : null;
                    }
                    const _a = this.config;
                    const { placeholder } = _a;
                    const { placeholderValue } = _a;
                    const { dataset } = this.passedElement.element;
                    if (placeholder) {
                      if (placeholderValue) {
                        return placeholderValue;
                      }
                      if (dataset.placeholder) {
                        return dataset.placeholder;
                      }
                    }
                    return null;
                  };
                  return Choices3;
                })();
              exports2.default = Choices2;
            },
          /***/
          613:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const utils_1 = __webpack_require__2(799);
              const constants_1 = __webpack_require__2(883);
              const Container =
                /** @class */
                (function () {
                  function Container2(_a) {
                    const { element } = _a;
                    const { type } = _a;
                    const { classNames } = _a;
                    const { position } = _a;
                    this.element = element;
                    this.classNames = classNames;
                    this.type = type;
                    this.position = position;
                    this.isOpen = false;
                    this.isFlipped = false;
                    this.isFocussed = false;
                    this.isDisabled = false;
                    this.isLoading = false;
                    this._onFocus = this._onFocus.bind(this);
                    this._onBlur = this._onBlur.bind(this);
                  }
                  Container2.prototype.addEventListeners = function () {
                    this.element.addEventListener("focus", this._onFocus);
                    this.element.addEventListener("blur", this._onBlur);
                  };
                  Container2.prototype.removeEventListeners = function () {
                    this.element.removeEventListener("focus", this._onFocus);
                    this.element.removeEventListener("blur", this._onBlur);
                  };
                  Container2.prototype.shouldFlip = function (dropdownPos) {
                    if (typeof dropdownPos !== "number") {
                      return false;
                    }
                    let shouldFlip = false;
                    if (this.position === "auto") {
                      shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
                    } else if (this.position === "top") {
                      shouldFlip = true;
                    }
                    return shouldFlip;
                  };
                  Container2.prototype.setActiveDescendant = function (activeDescendantID) {
                    this.element.setAttribute("aria-activedescendant", activeDescendantID);
                  };
                  Container2.prototype.removeActiveDescendant = function () {
                    this.element.removeAttribute("aria-activedescendant");
                  };
                  Container2.prototype.open = function (dropdownPos) {
                    this.element.classList.add(this.classNames.openState);
                    this.element.setAttribute("aria-expanded", "true");
                    this.isOpen = true;
                    if (this.shouldFlip(dropdownPos)) {
                      this.element.classList.add(this.classNames.flippedState);
                      this.isFlipped = true;
                    }
                  };
                  Container2.prototype.close = function () {
                    this.element.classList.remove(this.classNames.openState);
                    this.element.setAttribute("aria-expanded", "false");
                    this.removeActiveDescendant();
                    this.isOpen = false;
                    if (this.isFlipped) {
                      this.element.classList.remove(this.classNames.flippedState);
                      this.isFlipped = false;
                    }
                  };
                  Container2.prototype.focus = function () {
                    if (!this.isFocussed) {
                      this.element.focus();
                    }
                  };
                  Container2.prototype.addFocusState = function () {
                    this.element.classList.add(this.classNames.focusState);
                  };
                  Container2.prototype.removeFocusState = function () {
                    this.element.classList.remove(this.classNames.focusState);
                  };
                  Container2.prototype.enable = function () {
                    this.element.classList.remove(this.classNames.disabledState);
                    this.element.removeAttribute("aria-disabled");
                    if (this.type === constants_1.SELECT_ONE_TYPE) {
                      this.element.setAttribute("tabindex", "0");
                    }
                    this.isDisabled = false;
                  };
                  Container2.prototype.disable = function () {
                    this.element.classList.add(this.classNames.disabledState);
                    this.element.setAttribute("aria-disabled", "true");
                    if (this.type === constants_1.SELECT_ONE_TYPE) {
                      this.element.setAttribute("tabindex", "-1");
                    }
                    this.isDisabled = true;
                  };
                  Container2.prototype.wrap = function (element) {
                    (0, utils_1.wrap)(element, this.element);
                  };
                  Container2.prototype.unwrap = function (element) {
                    if (this.element.parentNode) {
                      this.element.parentNode.insertBefore(element, this.element);
                      this.element.parentNode.removeChild(this.element);
                    }
                  };
                  Container2.prototype.addLoadingState = function () {
                    this.element.classList.add(this.classNames.loadingState);
                    this.element.setAttribute("aria-busy", "true");
                    this.isLoading = true;
                  };
                  Container2.prototype.removeLoadingState = function () {
                    this.element.classList.remove(this.classNames.loadingState);
                    this.element.removeAttribute("aria-busy");
                    this.isLoading = false;
                  };
                  Container2.prototype._onFocus = function () {
                    this.isFocussed = true;
                  };
                  Container2.prototype._onBlur = function () {
                    this.isFocussed = false;
                  };
                  return Container2;
                })();
              exports2.default = Container;
            },
          /***/
          217:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const Dropdown =
                /** @class */
                (function () {
                  function Dropdown2(_a) {
                    const { element } = _a;
                    const { type } = _a;
                    const { classNames } = _a;
                    this.element = element;
                    this.classNames = classNames;
                    this.type = type;
                    this.isActive = false;
                  }
                  Object.defineProperty(Dropdown2.prototype, "distanceFromTopWindow", {
                    /**
                     * Bottom position of dropdown in viewport coordinates
                     */
                    get() {
                      return this.element.getBoundingClientRect().bottom;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Dropdown2.prototype.getChild = function (selector) {
                    return this.element.querySelector(selector);
                  };
                  Dropdown2.prototype.show = function () {
                    this.element.classList.add(this.classNames.activeState);
                    this.element.setAttribute("aria-expanded", "true");
                    this.isActive = true;
                    return this;
                  };
                  Dropdown2.prototype.hide = function () {
                    this.element.classList.remove(this.classNames.activeState);
                    this.element.setAttribute("aria-expanded", "false");
                    this.isActive = false;
                    return this;
                  };
                  return Dropdown2;
                })();
              exports2.default = Dropdown;
            },
          /***/
          520:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule
                    ? mod
                    : {
                        default: mod,
                      };
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.WrappedSelect = exports2.WrappedInput = exports2.List = exports2.Input = exports2.Container = exports2.Dropdown = void 0;
              const dropdown_1 = __importDefault(__webpack_require__2(217));
              exports2.Dropdown = dropdown_1.default;
              const container_1 = __importDefault(__webpack_require__2(613));
              exports2.Container = container_1.default;
              const input_1 = __importDefault(__webpack_require__2(11));
              exports2.Input = input_1.default;
              const list_1 = __importDefault(__webpack_require__2(624));
              exports2.List = list_1.default;
              const wrapped_input_1 = __importDefault(__webpack_require__2(541));
              exports2.WrappedInput = wrapped_input_1.default;
              const wrapped_select_1 = __importDefault(__webpack_require__2(982));
              exports2.WrappedSelect = wrapped_select_1.default;
            },
          /***/
          11:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const utils_1 = __webpack_require__2(799);
              const constants_1 = __webpack_require__2(883);
              const Input =
                /** @class */
                (function () {
                  function Input2(_a) {
                    const { element } = _a;
                    const { type } = _a;
                    const { classNames } = _a;
                    const { preventPaste } = _a;
                    this.element = element;
                    this.type = type;
                    this.classNames = classNames;
                    this.preventPaste = preventPaste;
                    this.isFocussed = this.element.isEqualNode(document.activeElement);
                    this.isDisabled = element.disabled;
                    this._onPaste = this._onPaste.bind(this);
                    this._onInput = this._onInput.bind(this);
                    this._onFocus = this._onFocus.bind(this);
                    this._onBlur = this._onBlur.bind(this);
                  }
                  Object.defineProperty(Input2.prototype, "placeholder", {
                    set(placeholder) {
                      this.element.placeholder = placeholder;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Input2.prototype, "value", {
                    get() {
                      return (0, utils_1.sanitise)(this.element.value);
                    },
                    set(value) {
                      this.element.value = value;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Input2.prototype, "rawValue", {
                    get() {
                      return this.element.value;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Input2.prototype.addEventListeners = function () {
                    this.element.addEventListener("paste", this._onPaste);
                    this.element.addEventListener("input", this._onInput, {
                      passive: true,
                    });
                    this.element.addEventListener("focus", this._onFocus, {
                      passive: true,
                    });
                    this.element.addEventListener("blur", this._onBlur, {
                      passive: true,
                    });
                  };
                  Input2.prototype.removeEventListeners = function () {
                    this.element.removeEventListener("input", this._onInput);
                    this.element.removeEventListener("paste", this._onPaste);
                    this.element.removeEventListener("focus", this._onFocus);
                    this.element.removeEventListener("blur", this._onBlur);
                  };
                  Input2.prototype.enable = function () {
                    this.element.removeAttribute("disabled");
                    this.isDisabled = false;
                  };
                  Input2.prototype.disable = function () {
                    this.element.setAttribute("disabled", "");
                    this.isDisabled = true;
                  };
                  Input2.prototype.focus = function () {
                    if (!this.isFocussed) {
                      this.element.focus();
                    }
                  };
                  Input2.prototype.blur = function () {
                    if (this.isFocussed) {
                      this.element.blur();
                    }
                  };
                  Input2.prototype.clear = function (setWidth) {
                    if (setWidth === void 0) {
                      setWidth = true;
                    }
                    if (this.element.value) {
                      this.element.value = "";
                    }
                    if (setWidth) {
                      this.setWidth();
                    }
                    return this;
                  };
                  Input2.prototype.setWidth = function () {
                    const _a = this.element;
                    const { style } = _a;
                    const { value } = _a;
                    const { placeholder } = _a;
                    style.minWidth = "".concat(placeholder.length + 1, "ch");
                    style.width = "".concat(value.length + 1, "ch");
                  };
                  Input2.prototype.setActiveDescendant = function (activeDescendantID) {
                    this.element.setAttribute("aria-activedescendant", activeDescendantID);
                  };
                  Input2.prototype.removeActiveDescendant = function () {
                    this.element.removeAttribute("aria-activedescendant");
                  };
                  Input2.prototype._onInput = function () {
                    if (this.type !== constants_1.SELECT_ONE_TYPE) {
                      this.setWidth();
                    }
                  };
                  Input2.prototype._onPaste = function (event) {
                    if (this.preventPaste) {
                      event.preventDefault();
                    }
                  };
                  Input2.prototype._onFocus = function () {
                    this.isFocussed = true;
                  };
                  Input2.prototype._onBlur = function () {
                    this.isFocussed = false;
                  };
                  return Input2;
                })();
              exports2.default = Input;
            },
          /***/
          624:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const constants_1 = __webpack_require__2(883);
              const List =
                /** @class */
                (function () {
                  function List2(_a) {
                    const { element } = _a;
                    this.element = element;
                    this.scrollPos = this.element.scrollTop;
                    this.height = this.element.offsetHeight;
                  }
                  List2.prototype.clear = function () {
                    this.element.innerHTML = "";
                  };
                  List2.prototype.append = function (node) {
                    this.element.appendChild(node);
                  };
                  List2.prototype.getChild = function (selector) {
                    return this.element.querySelector(selector);
                  };
                  List2.prototype.hasChildren = function () {
                    return this.element.hasChildNodes();
                  };
                  List2.prototype.scrollToTop = function () {
                    this.element.scrollTop = 0;
                  };
                  List2.prototype.scrollToChildElement = function (element, direction) {
                    const _this = this;
                    if (!element) {
                      return;
                    }
                    const listHeight = this.element.offsetHeight;
                    const listScrollPosition = this.element.scrollTop + listHeight;
                    const elementHeight = element.offsetHeight;
                    const elementPos = element.offsetTop + elementHeight;
                    const destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
                    requestAnimationFrame(function () {
                      _this._animateScroll(destination, direction);
                    });
                  };
                  List2.prototype._scrollDown = function (scrollPos, strength, destination) {
                    const easing = (destination - scrollPos) / strength;
                    const distance = easing > 1 ? easing : 1;
                    this.element.scrollTop = scrollPos + distance;
                  };
                  List2.prototype._scrollUp = function (scrollPos, strength, destination) {
                    const easing = (scrollPos - destination) / strength;
                    const distance = easing > 1 ? easing : 1;
                    this.element.scrollTop = scrollPos - distance;
                  };
                  List2.prototype._animateScroll = function (destination, direction) {
                    const _this = this;
                    const strength = constants_1.SCROLLING_SPEED;
                    const choiceListScrollTop = this.element.scrollTop;
                    let continueAnimation = false;
                    if (direction > 0) {
                      this._scrollDown(choiceListScrollTop, strength, destination);
                      if (choiceListScrollTop < destination) {
                        continueAnimation = true;
                      }
                    } else {
                      this._scrollUp(choiceListScrollTop, strength, destination);
                      if (choiceListScrollTop > destination) {
                        continueAnimation = true;
                      }
                    }
                    if (continueAnimation) {
                      requestAnimationFrame(function () {
                        _this._animateScroll(destination, direction);
                      });
                    }
                  };
                  return List2;
                })();
              exports2.default = List;
            },
          /***/
          730:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const utils_1 = __webpack_require__2(799);
              const WrappedElement =
                /** @class */
                (function () {
                  function WrappedElement2(_a) {
                    const { element } = _a;
                    const { classNames } = _a;
                    this.element = element;
                    this.classNames = classNames;
                    if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
                      throw new TypeError("Invalid element passed");
                    }
                    this.isDisabled = false;
                  }
                  Object.defineProperty(WrappedElement2.prototype, "isActive", {
                    get() {
                      return this.element.dataset.choice === "active";
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(WrappedElement2.prototype, "dir", {
                    get() {
                      return this.element.dir;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(WrappedElement2.prototype, "value", {
                    get() {
                      return this.element.value;
                    },
                    set(value) {
                      this.element.value = value;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  WrappedElement2.prototype.conceal = function () {
                    this.element.classList.add(this.classNames.input);
                    this.element.hidden = true;
                    this.element.tabIndex = -1;
                    const origStyle = this.element.getAttribute("style");
                    if (origStyle) {
                      this.element.setAttribute("data-choice-orig-style", origStyle);
                    }
                    this.element.setAttribute("data-choice", "active");
                  };
                  WrappedElement2.prototype.reveal = function () {
                    this.element.classList.remove(this.classNames.input);
                    this.element.hidden = false;
                    this.element.removeAttribute("tabindex");
                    const origStyle = this.element.getAttribute("data-choice-orig-style");
                    if (origStyle) {
                      this.element.removeAttribute("data-choice-orig-style");
                      this.element.setAttribute("style", origStyle);
                    } else {
                      this.element.removeAttribute("style");
                    }
                    this.element.removeAttribute("data-choice");
                    this.element.value = this.element.value;
                  };
                  WrappedElement2.prototype.enable = function () {
                    this.element.removeAttribute("disabled");
                    this.element.disabled = false;
                    this.isDisabled = false;
                  };
                  WrappedElement2.prototype.disable = function () {
                    this.element.setAttribute("disabled", "");
                    this.element.disabled = true;
                    this.isDisabled = true;
                  };
                  WrappedElement2.prototype.triggerEvent = function (eventType, data) {
                    (0, utils_1.dispatchEvent)(this.element, eventType, data);
                  };
                  return WrappedElement2;
                })();
              exports2.default = WrappedElement;
            },
          /***/
          541:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __extends =
                (this && this.__extends) ||
                (function () {
                  let extendStatics = function (d, b) {
                    extendStatics =
                      Object.setPrototypeOf ||
                      ({
                        __proto__: [],
                      } instanceof Array &&
                        function (d2, b2) {
                          d2.__proto__ = b2;
                        }) ||
                      function (d2, b2) {
                        for (const p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
                      };
                    return extendStatics(d, b);
                  };
                  return function (d, b) {
                    if (typeof b !== "function" && b !== null) throw new TypeError(`Class extends value ${String(b)} is not a constructor or null`);
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                  };
                })();
              const __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule
                    ? mod
                    : {
                        default: mod,
                      };
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const wrapped_element_1 = __importDefault(__webpack_require__2(730));
              const WrappedInput =
                /** @class */
                (function (_super) {
                  __extends(WrappedInput2, _super);
                  function WrappedInput2(_a) {
                    const { element } = _a;
                    const { classNames } = _a;
                    const { delimiter } = _a;
                    const _this =
                      _super.call(this, {
                        element,
                        classNames,
                      }) || this;
                    _this.delimiter = delimiter;
                    return _this;
                  }
                  Object.defineProperty(WrappedInput2.prototype, "value", {
                    get() {
                      return this.element.value;
                    },
                    set(value) {
                      this.element.setAttribute("value", value);
                      this.element.value = value;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  return WrappedInput2;
                })(wrapped_element_1.default);
              exports2.default = WrappedInput;
            },
          /***/
          982:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __extends =
                (this && this.__extends) ||
                (function () {
                  let extendStatics = function (d, b) {
                    extendStatics =
                      Object.setPrototypeOf ||
                      ({
                        __proto__: [],
                      } instanceof Array &&
                        function (d2, b2) {
                          d2.__proto__ = b2;
                        }) ||
                      function (d2, b2) {
                        for (const p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
                      };
                    return extendStatics(d, b);
                  };
                  return function (d, b) {
                    if (typeof b !== "function" && b !== null) throw new TypeError(`Class extends value ${String(b)} is not a constructor or null`);
                    extendStatics(d, b);
                    function __() {
                      this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
                  };
                })();
              const __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule
                    ? mod
                    : {
                        default: mod,
                      };
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const wrapped_element_1 = __importDefault(__webpack_require__2(730));
              const WrappedSelect =
                /** @class */
                (function (_super) {
                  __extends(WrappedSelect2, _super);
                  function WrappedSelect2(_a) {
                    const { element } = _a;
                    const { classNames } = _a;
                    const { template } = _a;
                    const _this =
                      _super.call(this, {
                        element,
                        classNames,
                      }) || this;
                    _this.template = template;
                    return _this;
                  }
                  Object.defineProperty(WrappedSelect2.prototype, "placeholderOption", {
                    get() {
                      return (
                        this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                        this.element.querySelector("option[placeholder]")
                      );
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(WrappedSelect2.prototype, "optionGroups", {
                    get() {
                      return Array.from(this.element.getElementsByTagName("OPTGROUP"));
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(WrappedSelect2.prototype, "options", {
                    get() {
                      return Array.from(this.element.options);
                    },
                    set(options) {
                      const _this = this;
                      const fragment = document.createDocumentFragment();
                      const addOptionToFragment = function (data) {
                        const option = _this.template(data);
                        fragment.appendChild(option);
                      };
                      options.forEach(function (optionData) {
                        return addOptionToFragment(optionData);
                      });
                      this.appendDocFragment(fragment);
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  WrappedSelect2.prototype.appendDocFragment = function (fragment) {
                    this.element.innerHTML = "";
                    this.element.appendChild(fragment);
                  };
                  return WrappedSelect2;
                })(wrapped_element_1.default);
              exports2.default = WrappedSelect;
            },
          /***/
          883:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.SCROLLING_SPEED = exports2.SELECT_MULTIPLE_TYPE = exports2.SELECT_ONE_TYPE = exports2.TEXT_TYPE = exports2.KEY_CODES = exports2.ACTION_TYPES = exports2.EVENTS = void 0;
              exports2.EVENTS = {
                showDropdown: "showDropdown",
                hideDropdown: "hideDropdown",
                change: "change",
                choice: "choice",
                search: "search",
                addItem: "addItem",
                removeItem: "removeItem",
                highlightItem: "highlightItem",
                highlightChoice: "highlightChoice",
                unhighlightItem: "unhighlightItem",
              };
              exports2.ACTION_TYPES = {
                ADD_CHOICE: "ADD_CHOICE",
                FILTER_CHOICES: "FILTER_CHOICES",
                ACTIVATE_CHOICES: "ACTIVATE_CHOICES",
                CLEAR_CHOICES: "CLEAR_CHOICES",
                ADD_GROUP: "ADD_GROUP",
                ADD_ITEM: "ADD_ITEM",
                REMOVE_ITEM: "REMOVE_ITEM",
                HIGHLIGHT_ITEM: "HIGHLIGHT_ITEM",
                CLEAR_ALL: "CLEAR_ALL",
                RESET_TO: "RESET_TO",
                SET_IS_LOADING: "SET_IS_LOADING",
              };
              exports2.KEY_CODES = {
                BACK_KEY: 46,
                DELETE_KEY: 8,
                ENTER_KEY: 13,
                A_KEY: 65,
                ESC_KEY: 27,
                UP_KEY: 38,
                DOWN_KEY: 40,
                PAGE_UP_KEY: 33,
                PAGE_DOWN_KEY: 34,
              };
              exports2.TEXT_TYPE = "text";
              exports2.SELECT_ONE_TYPE = "select-one";
              exports2.SELECT_MULTIPLE_TYPE = "select-multiple";
              exports2.SCROLLING_SPEED = 4;
            },
          /***/
          789:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.DEFAULT_CONFIG = exports2.DEFAULT_CLASSNAMES = void 0;
              const utils_1 = __webpack_require__2(799);
              exports2.DEFAULT_CLASSNAMES = {
                containerOuter: "choices",
                containerInner: "choices__inner",
                input: "choices__input",
                inputCloned: "choices__input--cloned",
                list: "choices__list",
                listItems: "choices__list--multiple",
                listSingle: "choices__list--single",
                listDropdown: "choices__list--dropdown",
                item: "choices__item",
                itemSelectable: "choices__item--selectable",
                itemDisabled: "choices__item--disabled",
                itemChoice: "choices__item--choice",
                placeholder: "choices__placeholder",
                group: "choices__group",
                groupHeading: "choices__heading",
                button: "choices__button",
                activeState: "is-active",
                focusState: "is-focused",
                openState: "is-open",
                disabledState: "is-disabled",
                highlightedState: "is-highlighted",
                selectedState: "is-selected",
                flippedState: "is-flipped",
                loadingState: "is-loading",
                noResults: "has-no-results",
                noChoices: "has-no-choices",
              };
              exports2.DEFAULT_CONFIG = {
                items: [],
                choices: [],
                silent: false,
                renderChoiceLimit: -1,
                maxItemCount: -1,
                addItems: true,
                addItemFilter: null,
                removeItems: true,
                removeItemButton: false,
                editItems: false,
                allowHTML: true,
                duplicateItemsAllowed: true,
                delimiter: ",",
                paste: true,
                searchEnabled: true,
                searchChoices: true,
                searchFloor: 1,
                searchResultLimit: 4,
                searchFields: ["label", "value"],
                position: "auto",
                resetScrollPosition: true,
                shouldSort: true,
                shouldSortItems: false,
                sorter: utils_1.sortByAlpha,
                placeholder: true,
                placeholderValue: null,
                searchPlaceholderValue: null,
                prependValue: null,
                appendValue: null,
                renderSelectedChoices: "auto",
                loadingText: "Loading...",
                noResultsText: "No results found",
                noChoicesText: "No choices to choose from",
                itemSelectText: "Press to select",
                uniqueItemText: "Only unique values can be added",
                customAddItemText: "Only values matching specific conditions can be added",
                addItemText(value) {
                  return 'Press Enter to add <b>"'.concat((0, utils_1.sanitise)(value), '"</b>');
                },
                maxItemText(maxItemCount) {
                  return "Only ".concat(maxItemCount, " values can be added");
                },
                valueComparer(value1, value2) {
                  return value1 === value2;
                },
                fuseOptions: {
                  includeScore: true,
                },
                labelId: "",
                callbackOnInit: null,
                callbackOnCreateTemplates: null,
                classNames: exports2.DEFAULT_CLASSNAMES,
              };
            },
          /***/
          18:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          978:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          948:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          359:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          285:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          533:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          187:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __createBinding =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (o, m, k, k2) {
                      if (k2 === void 0) k2 = k;
                      let desc = Object.getOwnPropertyDescriptor(m, k);
                      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                          enumerable: true,
                          get() {
                            return m[k];
                          },
                        };
                      }
                      Object.defineProperty(o, k2, desc);
                    }
                  : function (o, m, k, k2) {
                      if (k2 === void 0) k2 = k;
                      o[k2] = m[k];
                    });
              const __exportStar =
                (this && this.__exportStar) ||
                function (m, exports3) {
                  for (const p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              __exportStar(__webpack_require__2(18), exports2);
              __exportStar(__webpack_require__2(978), exports2);
              __exportStar(__webpack_require__2(948), exports2);
              __exportStar(__webpack_require__2(359), exports2);
              __exportStar(__webpack_require__2(285), exports2);
              __exportStar(__webpack_require__2(533), exports2);
              __exportStar(__webpack_require__2(287), exports2);
              __exportStar(__webpack_require__2(132), exports2);
              __exportStar(__webpack_require__2(837), exports2);
              __exportStar(__webpack_require__2(598), exports2);
              __exportStar(__webpack_require__2(369), exports2);
              __exportStar(__webpack_require__2(37), exports2);
              __exportStar(__webpack_require__2(47), exports2);
              __exportStar(__webpack_require__2(923), exports2);
              __exportStar(__webpack_require__2(876), exports2);
            },
          /***/
          287:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          132:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          837:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          598:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          37:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          369:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          47:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          923:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          876:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
            },
          /***/
          799:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.parseCustomProperties = exports2.diff = exports2.cloneObject = exports2.existsInArray = exports2.dispatchEvent = exports2.sortByScore = exports2.sortByAlpha = exports2.strToEl = exports2.sanitise = exports2.isScrolledIntoView = exports2.getAdjacentEl = exports2.wrap = exports2.isType = exports2.getType = exports2.generateId = exports2.generateChars = exports2.getRandomNumber = void 0;
              const getRandomNumber = function (min, max) {
                return Math.floor(Math.random() * (max - min) + min);
              };
              exports2.getRandomNumber = getRandomNumber;
              const generateChars = function (length) {
                return Array.from(
                  {
                    length,
                  },
                  function () {
                    return (0, exports2.getRandomNumber)(0, 36).toString(36);
                  },
                ).join("");
              };
              exports2.generateChars = generateChars;
              const generateId = function (element, prefix) {
                let id = element.id || (element.name && "".concat(element.name, "-").concat((0, exports2.generateChars)(2))) || (0, exports2.generateChars)(4);
                id = id.replace(/(:|\.|\[|\]|,)/g, "");
                id = "".concat(prefix, "-").concat(id);
                return id;
              };
              exports2.generateId = generateId;
              const getType = function (obj) {
                return Object.prototype.toString.call(obj).slice(8, -1);
              };
              exports2.getType = getType;
              const isType = function (type, obj) {
                return obj !== void 0 && obj !== null && (0, exports2.getType)(obj) === type;
              };
              exports2.isType = isType;
              const wrap = function (element, wrapper) {
                if (wrapper === void 0) {
                  wrapper = document.createElement("div");
                }
                if (element.parentNode) {
                  if (element.nextSibling) {
                    element.parentNode.insertBefore(wrapper, element.nextSibling);
                  } else {
                    element.parentNode.appendChild(wrapper);
                  }
                }
                return wrapper.appendChild(element);
              };
              exports2.wrap = wrap;
              const getAdjacentEl = function (startEl, selector, direction) {
                if (direction === void 0) {
                  direction = 1;
                }
                const prop = "".concat(direction > 0 ? "next" : "previous", "ElementSibling");
                let sibling = startEl[prop];
                while (sibling) {
                  if (sibling.matches(selector)) {
                    return sibling;
                  }
                  sibling = sibling[prop];
                }
                return sibling;
              };
              exports2.getAdjacentEl = getAdjacentEl;
              const isScrolledIntoView = function (element, parent, direction) {
                if (direction === void 0) {
                  direction = 1;
                }
                if (!element) {
                  return false;
                }
                let isVisible;
                if (direction > 0) {
                  isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
                } else {
                  isVisible = element.offsetTop >= parent.scrollTop;
                }
                return isVisible;
              };
              exports2.isScrolledIntoView = isScrolledIntoView;
              const sanitise = function (value) {
                if (typeof value !== "string") {
                  return value;
                }
                return value.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
              };
              exports2.sanitise = sanitise;
              exports2.strToEl = (function () {
                const tmpEl = document.createElement("div");
                return function (str) {
                  const cleanedInput = str.trim();
                  tmpEl.innerHTML = cleanedInput;
                  const firldChild = tmpEl.children[0];
                  while (tmpEl.firstChild) {
                    tmpEl.removeChild(tmpEl.firstChild);
                  }
                  return firldChild;
                };
              })();
              const sortByAlpha = function (_a, _b) {
                const { value } = _a;
                const _c = _a.label;
                const label = _c === void 0 ? value : _c;
                const value2 = _b.value;
                const _d = _b.label;
                const label2 = _d === void 0 ? value2 : _d;
                return label.localeCompare(label2, [], {
                  sensitivity: "base",
                  ignorePunctuation: true,
                  numeric: true,
                });
              };
              exports2.sortByAlpha = sortByAlpha;
              const sortByScore = function (a, b) {
                const _a = a.score;
                const scoreA = _a === void 0 ? 0 : _a;
                const _b = b.score;
                const scoreB = _b === void 0 ? 0 : _b;
                return scoreA - scoreB;
              };
              exports2.sortByScore = sortByScore;
              const dispatchEvent = function (element, type, customArgs) {
                if (customArgs === void 0) {
                  customArgs = null;
                }
                const event = new CustomEvent(type, {
                  detail: customArgs,
                  bubbles: true,
                  cancelable: true,
                });
                return element.dispatchEvent(event);
              };
              exports2.dispatchEvent = dispatchEvent;
              const existsInArray = function (array, value, key) {
                if (key === void 0) {
                  key = "value";
                }
                return array.some(function (item) {
                  if (typeof value === "string") {
                    return item[key] === value.trim();
                  }
                  return item[key] === value;
                });
              };
              exports2.existsInArray = existsInArray;
              const cloneObject = function (obj) {
                return JSON.parse(JSON.stringify(obj));
              };
              exports2.cloneObject = cloneObject;
              const diff = function (a, b) {
                const aKeys = Object.keys(a).sort();
                const bKeys = Object.keys(b).sort();
                return aKeys.filter(function (i) {
                  return bKeys.indexOf(i) < 0;
                });
              };
              exports2.diff = diff;
              const parseCustomProperties = function (customProperties) {
                if (typeof customProperties !== "undefined") {
                  try {
                    return JSON.parse(customProperties);
                  } catch (e) {
                    return customProperties;
                  }
                }
                return {};
              };
              exports2.parseCustomProperties = parseCustomProperties;
            },
          /***/
          273:
            /***/
            function (__unused_webpack_module, exports2) {
              const __spreadArray =
                (this && this.__spreadArray) ||
                function (to, from, pack) {
                  if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.defaultState = void 0;
              exports2.defaultState = [];
              function choices2(state, action) {
                if (state === void 0) {
                  state = exports2.defaultState;
                }
                if (action === void 0) {
                  action = {};
                }
                switch (action.type) {
                  case "ADD_CHOICE": {
                    const addChoiceAction = action;
                    const choice = {
                      id: addChoiceAction.id,
                      elementId: addChoiceAction.elementId,
                      groupId: addChoiceAction.groupId,
                      value: addChoiceAction.value,
                      label: addChoiceAction.label || addChoiceAction.value,
                      disabled: addChoiceAction.disabled || false,
                      selected: false,
                      active: true,
                      score: 9999,
                      customProperties: addChoiceAction.customProperties,
                      placeholder: addChoiceAction.placeholder || false,
                    };
                    return __spreadArray(__spreadArray([], state, true), [choice], false);
                  }
                  case "ADD_ITEM": {
                    const addItemAction_1 = action;
                    if (addItemAction_1.choiceId > -1) {
                      return state.map(function (obj) {
                        const choice2 = obj;
                        if (choice2.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
                          choice2.selected = true;
                        }
                        return choice2;
                      });
                    }
                    return state;
                  }
                  case "REMOVE_ITEM": {
                    const removeItemAction_1 = action;
                    if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
                      return state.map(function (obj) {
                        const choice2 = obj;
                        if (choice2.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
                          choice2.selected = false;
                        }
                        return choice2;
                      });
                    }
                    return state;
                  }
                  case "FILTER_CHOICES": {
                    const filterChoicesAction_1 = action;
                    return state.map(function (obj) {
                      const choice2 = obj;
                      choice2.active = filterChoicesAction_1.results.some(function (_a) {
                        const { item } = _a;
                        const { score } = _a;
                        if (item.id === choice2.id) {
                          choice2.score = score;
                          return true;
                        }
                        return false;
                      });
                      return choice2;
                    });
                  }
                  case "ACTIVATE_CHOICES": {
                    const activateChoicesAction_1 = action;
                    return state.map(function (obj) {
                      const choice2 = obj;
                      choice2.active = activateChoicesAction_1.active;
                      return choice2;
                    });
                  }
                  case "CLEAR_CHOICES": {
                    return exports2.defaultState;
                  }
                  default: {
                    return state;
                  }
                }
              }
              exports2.default = choices2;
            },
          /***/
          871:
            /***/
            function (__unused_webpack_module, exports2) {
              const __spreadArray =
                (this && this.__spreadArray) ||
                function (to, from, pack) {
                  if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.defaultState = void 0;
              exports2.defaultState = [];
              function groups(state, action) {
                if (state === void 0) {
                  state = exports2.defaultState;
                }
                if (action === void 0) {
                  action = {};
                }
                switch (action.type) {
                  case "ADD_GROUP": {
                    const addGroupAction = action;
                    return __spreadArray(
                      __spreadArray([], state, true),
                      [
                        {
                          id: addGroupAction.id,
                          value: addGroupAction.value,
                          active: addGroupAction.active,
                          disabled: addGroupAction.disabled,
                        },
                      ],
                      false,
                    );
                  }
                  case "CLEAR_CHOICES": {
                    return [];
                  }
                  default: {
                    return state;
                  }
                }
              }
              exports2.default = groups;
            },
          /***/
          655:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule
                    ? mod
                    : {
                        default: mod,
                      };
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.defaultState = void 0;
              const redux_1 = __webpack_require__2(791);
              const items_1 = __importDefault(__webpack_require__2(52));
              const groups_1 = __importDefault(__webpack_require__2(871));
              const choices_1 = __importDefault(__webpack_require__2(273));
              const loading_1 = __importDefault(__webpack_require__2(502));
              const utils_1 = __webpack_require__2(799);
              exports2.defaultState = {
                groups: [],
                items: [],
                choices: [],
                loading: false,
              };
              const appReducer = (0, redux_1.combineReducers)({
                items: items_1.default,
                groups: groups_1.default,
                choices: choices_1.default,
                loading: loading_1.default,
              });
              const rootReducer = function (passedState, action) {
                let state = passedState;
                if (action.type === "CLEAR_ALL") {
                  state = exports2.defaultState;
                } else if (action.type === "RESET_TO") {
                  return (0, utils_1.cloneObject)(action.state);
                }
                return appReducer(state, action);
              };
              exports2.default = rootReducer;
            },
          /***/
          52:
            /***/
            function (__unused_webpack_module, exports2) {
              const __spreadArray =
                (this && this.__spreadArray) ||
                function (to, from, pack) {
                  if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.defaultState = void 0;
              exports2.defaultState = [];
              function items(state, action) {
                if (state === void 0) {
                  state = exports2.defaultState;
                }
                if (action === void 0) {
                  action = {};
                }
                switch (action.type) {
                  case "ADD_ITEM": {
                    const addItemAction = action;
                    const newState = __spreadArray(
                      __spreadArray([], state, true),
                      [
                        {
                          id: addItemAction.id,
                          choiceId: addItemAction.choiceId,
                          groupId: addItemAction.groupId,
                          value: addItemAction.value,
                          label: addItemAction.label,
                          active: true,
                          highlighted: false,
                          customProperties: addItemAction.customProperties,
                          placeholder: addItemAction.placeholder || false,
                          keyCode: null,
                        },
                      ],
                      false,
                    );
                    return newState.map(function (obj) {
                      const item = obj;
                      item.highlighted = false;
                      return item;
                    });
                  }
                  case "REMOVE_ITEM": {
                    return state.map(function (obj) {
                      const item = obj;
                      if (item.id === action.id) {
                        item.active = false;
                      }
                      return item;
                    });
                  }
                  case "HIGHLIGHT_ITEM": {
                    const highlightItemAction_1 = action;
                    return state.map(function (obj) {
                      const item = obj;
                      if (item.id === highlightItemAction_1.id) {
                        item.highlighted = highlightItemAction_1.highlighted;
                      }
                      return item;
                    });
                  }
                  default: {
                    return state;
                  }
                }
              }
              exports2.default = items;
            },
          /***/
          502:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              exports2.defaultState = void 0;
              exports2.defaultState = false;
              const general = function (state, action) {
                if (state === void 0) {
                  state = exports2.defaultState;
                }
                if (action === void 0) {
                  action = {};
                }
                switch (action.type) {
                  case "SET_IS_LOADING": {
                    return action.isLoading;
                  }
                  default: {
                    return state;
                  }
                }
              };
              exports2.default = general;
            },
          /***/
          744:
            /***/
            function (__unused_webpack_module, exports2, __webpack_require__2) {
              const __spreadArray =
                (this && this.__spreadArray) ||
                function (to, from, pack) {
                  if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                  return to.concat(ar || Array.prototype.slice.call(from));
                };
              const __importDefault =
                (this && this.__importDefault) ||
                function (mod) {
                  return mod && mod.__esModule
                    ? mod
                    : {
                        default: mod,
                      };
                };
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const redux_1 = __webpack_require__2(791);
              const index_1 = __importDefault(__webpack_require__2(655));
              const Store =
                /** @class */
                (function () {
                  function Store2() {
                    this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
                  }
                  Store2.prototype.subscribe = function (onChange) {
                    this._store.subscribe(onChange);
                  };
                  Store2.prototype.dispatch = function (action) {
                    this._store.dispatch(action);
                  };
                  Object.defineProperty(Store2.prototype, "state", {
                    /**
                     * Get store object (wrapping Redux method)
                     */
                    get() {
                      return this._store.getState();
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "items", {
                    /**
                     * Get items from store
                     */
                    get() {
                      return this.state.items;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "activeItems", {
                    /**
                     * Get active items from store
                     */
                    get() {
                      return this.items.filter(function (item) {
                        return item.active === true;
                      });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "highlightedActiveItems", {
                    /**
                     * Get highlighted items from store
                     */
                    get() {
                      return this.items.filter(function (item) {
                        return item.active && item.highlighted;
                      });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "choices", {
                    /**
                     * Get choices from store
                     */
                    get() {
                      return this.state.choices;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "activeChoices", {
                    /**
                     * Get active choices from store
                     */
                    get() {
                      return this.choices.filter(function (choice) {
                        return choice.active === true;
                      });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "selectableChoices", {
                    /**
                     * Get selectable choices from store
                     */
                    get() {
                      return this.choices.filter(function (choice) {
                        return choice.disabled !== true;
                      });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "searchableChoices", {
                    /**
                     * Get choices that can be searched (excluding placeholders)
                     */
                    get() {
                      return this.selectableChoices.filter(function (choice) {
                        return choice.placeholder !== true;
                      });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "placeholderChoice", {
                    /**
                     * Get placeholder choice from store
                     */
                    get() {
                      return __spreadArray([], this.choices, true)
                        .reverse()
                        .find(function (choice) {
                          return choice.placeholder === true;
                        });
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "groups", {
                    /**
                     * Get groups from store
                     */
                    get() {
                      return this.state.groups;
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Object.defineProperty(Store2.prototype, "activeGroups", {
                    /**
                     * Get active groups from store
                     */
                    get() {
                      const _a = this;
                      const { groups } = _a;
                      const choices2 = _a.choices;
                      return groups.filter(function (group) {
                        const isActive = group.active === true && group.disabled === false;
                        const hasActiveOptions = choices2.some(function (choice) {
                          return choice.active === true && choice.disabled === false;
                        });
                        return isActive && hasActiveOptions;
                      }, []);
                    },
                    enumerable: false,
                    configurable: true,
                  });
                  Store2.prototype.isLoading = function () {
                    return this.state.loading;
                  };
                  Store2.prototype.getChoiceById = function (id) {
                    return this.activeChoices.find(function (choice) {
                      return choice.id === parseInt(id, 10);
                    });
                  };
                  Store2.prototype.getGroupById = function (id) {
                    return this.groups.find(function (group) {
                      return group.id === id;
                    });
                  };
                  return Store2;
                })();
              exports2.default = Store;
            },
          /***/
          686:
            /***/
            function (__unused_webpack_module, exports2) {
              Object.defineProperty(exports2, "__esModule", {
                value: true,
              });
              const templates = {
                containerOuter(_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
                  const { containerOuter } = _a.classNames;
                  const div = Object.assign(document.createElement("div"), {
                    className: containerOuter,
                  });
                  div.dataset.type = passedElementType;
                  if (dir) {
                    div.dir = dir;
                  }
                  if (isSelectOneElement) {
                    div.tabIndex = 0;
                  }
                  if (isSelectElement) {
                    div.setAttribute("role", searchEnabled ? "combobox" : "listbox");
                    if (searchEnabled) {
                      div.setAttribute("aria-autocomplete", "list");
                    }
                  }
                  div.setAttribute("aria-haspopup", "true");
                  div.setAttribute("aria-expanded", "false");
                  if (labelId) {
                    div.setAttribute("aria-labelledby", labelId);
                  }
                  return div;
                },
                containerInner(_a) {
                  const { containerInner } = _a.classNames;
                  return Object.assign(document.createElement("div"), {
                    className: containerInner,
                  });
                },
                itemList(_a, isSelectOneElement) {
                  const _b = _a.classNames;
                  const { list } = _b;
                  const { listSingle } = _b;
                  const { listItems } = _b;
                  return Object.assign(document.createElement("div"), {
                    className: "".concat(list, " ").concat(isSelectOneElement ? listSingle : listItems),
                  });
                },
                placeholder(_a, value) {
                  let _b;
                  const { allowHTML } = _a;
                  const { placeholder } = _a.classNames;
                  return Object.assign(
                    document.createElement("div"),
                    ((_b = {
                      className: placeholder,
                    }),
                    (_b[allowHTML ? "innerHTML" : "innerText"] = value),
                    _b),
                  );
                },
                item(_a, _b, removeItemButton) {
                  let _c;
                  let _d;
                  const { allowHTML } = _a;
                  const _e = _a.classNames;
                  const { item } = _e;
                  const { button } = _e;
                  const { highlightedState } = _e;
                  const { itemSelectable } = _e;
                  const { placeholder } = _e;
                  const { id } = _b;
                  const { value } = _b;
                  const { label } = _b;
                  const { customProperties } = _b;
                  const { active } = _b;
                  const { disabled } = _b;
                  const { highlighted } = _b;
                  const isPlaceholder = _b.placeholder;
                  const div = Object.assign(
                    document.createElement("div"),
                    ((_c = {
                      className: item,
                    }),
                    (_c[allowHTML ? "innerHTML" : "innerText"] = label),
                    _c),
                  );
                  Object.assign(div.dataset, {
                    item: "",
                    id,
                    value,
                    customProperties,
                  });
                  if (active) {
                    div.setAttribute("aria-selected", "true");
                  }
                  if (disabled) {
                    div.setAttribute("aria-disabled", "true");
                  }
                  if (isPlaceholder) {
                    div.classList.add(placeholder);
                  }
                  div.classList.add(highlighted ? highlightedState : itemSelectable);
                  if (removeItemButton) {
                    if (disabled) {
                      div.classList.remove(itemSelectable);
                    }
                    div.dataset.deletable = "";
                    const REMOVE_ITEM_TEXT = "Remove item";
                    const removeButton = Object.assign(
                      document.createElement("button"),
                      ((_d = {
                        type: "button",
                        className: button,
                      }),
                      (_d[allowHTML ? "innerHTML" : "innerText"] = REMOVE_ITEM_TEXT),
                      _d),
                    );
                    removeButton.setAttribute("aria-label", "".concat(REMOVE_ITEM_TEXT, ": '").concat(value, "'"));
                    removeButton.dataset.button = "";
                    div.appendChild(removeButton);
                  }
                  return div;
                },
                choiceList(_a, isSelectOneElement) {
                  const { list } = _a.classNames;
                  const div = Object.assign(document.createElement("div"), {
                    className: list,
                  });
                  if (!isSelectOneElement) {
                    div.setAttribute("aria-multiselectable", "true");
                  }
                  div.setAttribute("role", "listbox");
                  return div;
                },
                choiceGroup(_a, _b) {
                  let _c;
                  const { allowHTML } = _a;
                  const _d = _a.classNames;
                  const { group } = _d;
                  const { groupHeading } = _d;
                  const { itemDisabled } = _d;
                  const { id } = _b;
                  const { value } = _b;
                  const { disabled } = _b;
                  const div = Object.assign(document.createElement("div"), {
                    className: "".concat(group, " ").concat(disabled ? itemDisabled : ""),
                  });
                  div.setAttribute("role", "group");
                  Object.assign(div.dataset, {
                    group: "",
                    id,
                    value,
                  });
                  if (disabled) {
                    div.setAttribute("aria-disabled", "true");
                  }
                  div.appendChild(
                    Object.assign(
                      document.createElement("div"),
                      ((_c = {
                        className: groupHeading,
                      }),
                      (_c[allowHTML ? "innerHTML" : "innerText"] = value),
                      _c),
                    ),
                  );
                  return div;
                },
                choice(_a, _b, selectText) {
                  let _c;
                  const { allowHTML } = _a;
                  const _d = _a.classNames;
                  const { item } = _d;
                  const { itemChoice } = _d;
                  const { itemSelectable } = _d;
                  const { selectedState } = _d;
                  const { itemDisabled } = _d;
                  const { placeholder } = _d;
                  const { id } = _b;
                  const { value } = _b;
                  const { label } = _b;
                  const { groupId } = _b;
                  const { elementId } = _b;
                  const isDisabled = _b.disabled;
                  const isSelected = _b.selected;
                  const isPlaceholder = _b.placeholder;
                  const div = Object.assign(
                    document.createElement("div"),
                    ((_c = {
                      id: elementId,
                    }),
                    (_c[allowHTML ? "innerHTML" : "innerText"] = label),
                    (_c.className = "".concat(item, " ").concat(itemChoice)),
                    _c),
                  );
                  if (isSelected) {
                    div.classList.add(selectedState);
                  }
                  if (isPlaceholder) {
                    div.classList.add(placeholder);
                  }
                  div.setAttribute("role", groupId && groupId > 0 ? "treeitem" : "option");
                  Object.assign(div.dataset, {
                    choice: "",
                    id,
                    value,
                    selectText,
                  });
                  if (isDisabled) {
                    div.classList.add(itemDisabled);
                    div.dataset.choiceDisabled = "";
                    div.setAttribute("aria-disabled", "true");
                  } else {
                    div.classList.add(itemSelectable);
                    div.dataset.choiceSelectable = "";
                  }
                  return div;
                },
                input(_a, placeholderValue) {
                  const _b = _a.classNames;
                  const { input } = _b;
                  const { inputCloned } = _b;
                  const inp = Object.assign(document.createElement("input"), {
                    type: "search",
                    name: "search_terms",
                    className: "".concat(input, " ").concat(inputCloned),
                    autocomplete: "off",
                    autocapitalize: "off",
                    spellcheck: false,
                  });
                  inp.setAttribute("role", "textbox");
                  inp.setAttribute("aria-autocomplete", "list");
                  inp.setAttribute("aria-label", placeholderValue);
                  return inp;
                },
                dropdown(_a) {
                  const _b = _a.classNames;
                  const { list } = _b;
                  const { listDropdown } = _b;
                  const div = document.createElement("div");
                  div.classList.add(list, listDropdown);
                  div.setAttribute("aria-expanded", "false");
                  return div;
                },
                notice(_a, innerText, type) {
                  let _b;
                  const { allowHTML } = _a;
                  const _c = _a.classNames;
                  const { item } = _c;
                  const { itemChoice } = _c;
                  const { noResults } = _c;
                  const { noChoices } = _c;
                  if (type === void 0) {
                    type = "";
                  }
                  const classes = [item, itemChoice];
                  if (type === "no-choices") {
                    classes.push(noChoices);
                  } else if (type === "no-results") {
                    classes.push(noResults);
                  }
                  return Object.assign(document.createElement("div"), ((_b = {}), (_b[allowHTML ? "innerHTML" : "innerText"] = innerText), (_b.className = classes.join(" ")), _b));
                },
                option(_a) {
                  const { label } = _a;
                  const { value } = _a;
                  const { customProperties } = _a;
                  const { active } = _a;
                  const { disabled } = _a;
                  const opt = new Option(label, value, false, active);
                  if (customProperties) {
                    opt.dataset.customProperties = "".concat(customProperties);
                  }
                  opt.disabled = !!disabled;
                  return opt;
                },
              };
              exports2.default = templates;
            },
          /***/
          996:
            /***/
            function (module2) {
              const isMergeableObject = function isMergeableObject2(value) {
                return isNonNullObject(value) && !isSpecial(value);
              };
              function isNonNullObject(value) {
                return !!value && typeof value === "object";
              }
              function isSpecial(value) {
                const stringValue = Object.prototype.toString.call(value);
                return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
              }
              const canUseSymbol = typeof Symbol === "function" && Symbol.for;
              const REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
              function isReactElement(value) {
                return value.$$typeof === REACT_ELEMENT_TYPE;
              }
              function emptyTarget(val) {
                return Array.isArray(val) ? [] : {};
              }
              function cloneUnlessOtherwiseSpecified(value, options) {
                return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
              }
              function defaultArrayMerge(target, source, options) {
                return target.concat(source).map(function (element) {
                  return cloneUnlessOtherwiseSpecified(element, options);
                });
              }
              function getMergeFunction(key, options) {
                if (!options.customMerge) {
                  return deepmerge;
                }
                const customMerge = options.customMerge(key);
                return typeof customMerge === "function" ? customMerge : deepmerge;
              }
              function getEnumerableOwnPropertySymbols(target) {
                return Object.getOwnPropertySymbols
                  ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
                      return target.propertyIsEnumerable(symbol);
                    })
                  : [];
              }
              function getKeys(target) {
                return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
              }
              function propertyIsOnObject(object, property) {
                try {
                  return property in object;
                } catch (_) {
                  return false;
                }
              }
              function propertyIsUnsafe(target, key) {
                return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
              }
              function mergeObject(target, source, options) {
                const destination = {};
                if (options.isMergeableObject(target)) {
                  getKeys(target).forEach(function (key) {
                    destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
                  });
                }
                getKeys(source).forEach(function (key) {
                  if (propertyIsUnsafe(target, key)) {
                    return;
                  }
                  if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
                    destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
                  } else {
                    destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
                  }
                });
                return destination;
              }
              function deepmerge(target, source, options) {
                options = options || {};
                options.arrayMerge = options.arrayMerge || defaultArrayMerge;
                options.isMergeableObject = options.isMergeableObject || isMergeableObject;
                options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
                const sourceIsArray = Array.isArray(source);
                const targetIsArray = Array.isArray(target);
                const sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
                if (!sourceAndTargetTypesMatch) {
                  return cloneUnlessOtherwiseSpecified(source, options);
                }
                if (sourceIsArray) {
                  return options.arrayMerge(target, source, options);
                }
                return mergeObject(target, source, options);
              }
              deepmerge.all = function deepmergeAll(array, options) {
                if (!Array.isArray(array)) {
                  throw new Error("first argument should be an array");
                }
                return array.reduce(function (prev, next) {
                  return deepmerge(prev, next, options);
                }, {});
              };
              const deepmerge_1 = deepmerge;
              module2.exports = deepmerge_1;
            },
          /***/
          221:
            /***/
            function (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                /* harmony export */
                default() {
                  return (
                    /* binding */
                    Fuse
                  );
                },
                /* harmony export */
              });
              function isArray(value) {
                return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
              }
              const INFINITY = 1 / 0;
              function baseToString(value) {
                if (typeof value === "string") {
                  return value;
                }
                const result = `${value}`;
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              function isString(value) {
                return typeof value === "string";
              }
              function isNumber(value) {
                return typeof value === "number";
              }
              function isBoolean(value) {
                return value === true || value === false || (isObjectLike(value) && getTag(value) == "[object Boolean]");
              }
              function isObject(value) {
                return typeof value === "object";
              }
              function isObjectLike(value) {
                return isObject(value) && value !== null;
              }
              function isDefined(value) {
                return value !== void 0 && value !== null;
              }
              function isBlank(value) {
                return !value.trim().length;
              }
              function getTag(value) {
                return value == null ? (value === void 0 ? "[object Undefined]" : "[object Null]") : Object.prototype.toString.call(value);
              }
              const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
              const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
              const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
              const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
              const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
              const hasOwn = Object.prototype.hasOwnProperty;
              class KeyStore {
                constructor(keys) {
                  this._keys = [];
                  this._keyMap = {};
                  let totalWeight = 0;
                  keys.forEach((key) => {
                    const obj = createKey(key);
                    totalWeight += obj.weight;
                    this._keys.push(obj);
                    this._keyMap[obj.id] = obj;
                    totalWeight += obj.weight;
                  });
                  this._keys.forEach((key) => {
                    key.weight /= totalWeight;
                  });
                }

                get(keyId) {
                  return this._keyMap[keyId];
                }

                keys() {
                  return this._keys;
                }

                toJSON() {
                  return JSON.stringify(this._keys);
                }
              }
              function createKey(key) {
                let path = null;
                let id = null;
                let src = null;
                let weight = 1;
                let getFn = null;
                if (isString(key) || isArray(key)) {
                  src = key;
                  path = createKeyPath(key);
                  id = createKeyId(key);
                } else {
                  if (!hasOwn.call(key, "name")) {
                    throw new Error(MISSING_KEY_PROPERTY("name"));
                  }
                  const { name } = key;
                  src = name;
                  if (hasOwn.call(key, "weight")) {
                    weight = key.weight;
                    if (weight <= 0) {
                      throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
                    }
                  }
                  path = createKeyPath(name);
                  id = createKeyId(name);
                  getFn = key.getFn;
                }
                return { path, id, weight, src, getFn };
              }
              function createKeyPath(key) {
                return isArray(key) ? key : key.split(".");
              }
              function createKeyId(key) {
                return isArray(key) ? key.join(".") : key;
              }
              function get(obj, path) {
                const list = [];
                let arr = false;
                const deepGet = (obj2, path2, index) => {
                  if (!isDefined(obj2)) {
                    return;
                  }
                  if (!path2[index]) {
                    list.push(obj2);
                  } else {
                    const key = path2[index];
                    const value = obj2[key];
                    if (!isDefined(value)) {
                      return;
                    }
                    if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
                      list.push(toString(value));
                    } else if (isArray(value)) {
                      arr = true;
                      for (let i = 0, len = value.length; i < len; i += 1) {
                        deepGet(value[i], path2, index + 1);
                      }
                    } else if (path2.length) {
                      deepGet(value, path2, index + 1);
                    }
                  }
                };
                deepGet(obj, isString(path) ? path.split(".") : path, 0);
                return arr ? list : list[0];
              }
              const MatchOptions = {
                // Whether the matches should be included in the result set. When `true`, each record in the result
                // set will include the indices of the matched characters.
                // These can consequently be used for highlighting purposes.
                includeMatches: false,
                // When `true`, the matching function will continue to the end of a search pattern even if
                // a perfect match has already been located in the string.
                findAllMatches: false,
                // Minimum number of characters that must be matched before a result is considered a match
                minMatchCharLength: 1,
              };
              const BasicOptions = {
                // When `true`, the algorithm continues searching to the end of the input even if a perfect
                // match is found before the end of the same input.
                isCaseSensitive: false,
                // When true, the matching function will continue to the end of a search pattern even if
                includeScore: false,
                // List of properties that will be searched. This also supports nested properties.
                keys: [],
                // Whether to sort the result list, by score
                shouldSort: true,
                // Default sort function: sort by ascending score, ascending index
                sortFn: (a, b) => (a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1),
              };
              const FuzzyOptions = {
                // Approximately where in the text is the pattern expected to be found?
                location: 0,
                // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
                // (of both letters and location), a threshold of '1.0' would match anything.
                threshold: 0.6,
                // Determines how close the match must be to the fuzzy location (specified above).
                // An exact letter match which is 'distance' characters away from the fuzzy location
                // would score as a complete mismatch. A distance of '0' requires the match be at
                // the exact location specified, a threshold of '1000' would require a perfect match
                // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
                distance: 100,
              };
              const AdvancedOptions = {
                // When `true`, it enables the use of unix-like search commands
                useExtendedSearch: false,
                // The get function to use when fetching an object's properties.
                // The default will search nested paths *ie foo.bar.baz*
                getFn: get,
                // When `true`, search will ignore `location` and `distance`, so it won't matter
                // where in the string the pattern appears.
                // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
                ignoreLocation: false,
                // When `true`, the calculation for the relevance score (used for sorting) will
                // ignore the field-length norm.
                // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
                ignoreFieldNorm: false,
                // The weight to determine how much field length norm effects scoring.
                fieldNormWeight: 1,
              };
              const Config = {
                ...BasicOptions,
                ...MatchOptions,
                ...FuzzyOptions,
                ...AdvancedOptions,
              };
              const SPACE = /[^ ]+/g;
              function norm(weight = 1, mantissa = 3) {
                const cache = /* @__PURE__ */ new Map();
                const m = 10 ** mantissa;
                return {
                  get(value) {
                    const numTokens = value.match(SPACE).length;
                    if (cache.has(numTokens)) {
                      return cache.get(numTokens);
                    }
                    const norm2 = 1 / numTokens ** (0.5 * weight);
                    const n = parseFloat(Math.round(norm2 * m) / m);
                    cache.set(numTokens, n);
                    return n;
                  },
                  clear() {
                    cache.clear();
                  },
                };
              }
              class FuseIndex {
                constructor({ getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
                  this.norm = norm(fieldNormWeight, 3);
                  this.getFn = getFn;
                  this.isCreated = false;
                  this.setIndexRecords();
                }

                setSources(docs = []) {
                  this.docs = docs;
                }

                setIndexRecords(records = []) {
                  this.records = records;
                }

                setKeys(keys = []) {
                  this.keys = keys;
                  this._keysMap = {};
                  keys.forEach((key, idx) => {
                    this._keysMap[key.id] = idx;
                  });
                }

                create() {
                  if (this.isCreated || !this.docs.length) {
                    return;
                  }
                  this.isCreated = true;
                  if (isString(this.docs[0])) {
                    this.docs.forEach((doc, docIndex) => {
                      this._addString(doc, docIndex);
                    });
                  } else {
                    this.docs.forEach((doc, docIndex) => {
                      this._addObject(doc, docIndex);
                    });
                  }
                  this.norm.clear();
                }

                // Adds a doc to the end of the index
                add(doc) {
                  const idx = this.size();
                  if (isString(doc)) {
                    this._addString(doc, idx);
                  } else {
                    this._addObject(doc, idx);
                  }
                }

                // Removes the doc at the specified index of the index
                removeAt(idx) {
                  this.records.splice(idx, 1);
                  for (let i = idx, len = this.size(); i < len; i += 1) {
                    this.records[i].i -= 1;
                  }
                }

                getValueForItemAtKeyId(item, keyId) {
                  return item[this._keysMap[keyId]];
                }

                size() {
                  return this.records.length;
                }

                _addString(doc, docIndex) {
                  if (!isDefined(doc) || isBlank(doc)) {
                    return;
                  }
                  const record = {
                    v: doc,
                    i: docIndex,
                    n: this.norm.get(doc),
                  };
                  this.records.push(record);
                }

                _addObject(doc, docIndex) {
                  const record = { i: docIndex, $: {} };
                  this.keys.forEach((key, keyIndex) => {
                    const value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
                    if (!isDefined(value)) {
                      return;
                    }
                    if (isArray(value)) {
                      const subRecords = [];
                      const stack = [{ nestedArrIndex: -1, value }];
                      while (stack.length) {
                        const { nestedArrIndex, value: value2 } = stack.pop();
                        if (!isDefined(value2)) {
                          continue;
                        }
                        if (isString(value2) && !isBlank(value2)) {
                          const subRecord = {
                            v: value2,
                            i: nestedArrIndex,
                            n: this.norm.get(value2),
                          };
                          subRecords.push(subRecord);
                        } else if (isArray(value2)) {
                          value2.forEach((item, k) => {
                            stack.push({
                              nestedArrIndex: k,
                              value: item,
                            });
                          });
                        } else;
                      }
                      record.$[keyIndex] = subRecords;
                    } else if (isString(value) && !isBlank(value)) {
                      const subRecord = {
                        v: value,
                        n: this.norm.get(value),
                      };
                      record.$[keyIndex] = subRecord;
                    }
                  });
                  this.records.push(record);
                }

                toJSON() {
                  return {
                    keys: this.keys,
                    records: this.records,
                  };
                }
              }
              function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
                const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                myIndex.setKeys(keys.map(createKey));
                myIndex.setSources(docs);
                myIndex.create();
                return myIndex;
              }
              function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
                const { keys, records } = data;
                const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                myIndex.setKeys(keys);
                myIndex.setIndexRecords(records);
                return myIndex;
              }
              function computeScore$1(pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {
                const accuracy = errors / pattern.length;
                if (ignoreLocation) {
                  return accuracy;
                }
                const proximity = Math.abs(expectedLocation - currentLocation);
                if (!distance) {
                  return proximity ? 1 : accuracy;
                }
                return accuracy + proximity / distance;
              }
              function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
                const indices = [];
                let start = -1;
                let end = -1;
                let i = 0;
                for (let len = matchmask.length; i < len; i += 1) {
                  const match = matchmask[i];
                  if (match && start === -1) {
                    start = i;
                  } else if (!match && start !== -1) {
                    end = i - 1;
                    if (end - start + 1 >= minMatchCharLength) {
                      indices.push([start, end]);
                    }
                    start = -1;
                  }
                }
                if (matchmask[i - 1] && i - start >= minMatchCharLength) {
                  indices.push([start, i - 1]);
                }
                return indices;
              }
              const MAX_BITS = 32;
              function search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {
                if (pattern.length > MAX_BITS) {
                  throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
                }
                const patternLen = pattern.length;
                const textLen = text.length;
                const expectedLocation = Math.max(0, Math.min(location, textLen));
                let currentThreshold = threshold;
                let bestLocation = expectedLocation;
                const computeMatches = minMatchCharLength > 1 || includeMatches;
                const matchMask = computeMatches ? Array(textLen) : [];
                let index;
                while ((index = text.indexOf(pattern, bestLocation)) > -1) {
                  const score = computeScore$1(pattern, {
                    currentLocation: index,
                    expectedLocation,
                    distance,
                    ignoreLocation,
                  });
                  currentThreshold = Math.min(score, currentThreshold);
                  bestLocation = index + patternLen;
                  if (computeMatches) {
                    let i = 0;
                    while (i < patternLen) {
                      matchMask[index + i] = 1;
                      i += 1;
                    }
                  }
                }
                bestLocation = -1;
                let lastBitArr = [];
                let finalScore = 1;
                let binMax = patternLen + textLen;
                const mask = 1 << (patternLen - 1);
                for (let i = 0; i < patternLen; i += 1) {
                  let binMin = 0;
                  let binMid = binMax;
                  while (binMin < binMid) {
                    const score2 = computeScore$1(pattern, {
                      errors: i,
                      currentLocation: expectedLocation + binMid,
                      expectedLocation,
                      distance,
                      ignoreLocation,
                    });
                    if (score2 <= currentThreshold) {
                      binMin = binMid;
                    } else {
                      binMax = binMid;
                    }
                    binMid = Math.floor((binMax - binMin) / 2 + binMin);
                  }
                  binMax = binMid;
                  let start = Math.max(1, expectedLocation - binMid + 1);
                  const finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
                  const bitArr = Array(finish + 2);
                  bitArr[finish + 1] = (1 << i) - 1;
                  for (let j = finish; j >= start; j -= 1) {
                    const currentLocation = j - 1;
                    const charMatch = patternAlphabet[text.charAt(currentLocation)];
                    if (computeMatches) {
                      matchMask[currentLocation] = +!!charMatch;
                    }
                    bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;
                    if (i) {
                      bitArr[j] |= ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
                    }
                    if (bitArr[j] & mask) {
                      finalScore = computeScore$1(pattern, {
                        errors: i,
                        currentLocation,
                        expectedLocation,
                        distance,
                        ignoreLocation,
                      });
                      if (finalScore <= currentThreshold) {
                        currentThreshold = finalScore;
                        bestLocation = currentLocation;
                        if (bestLocation <= expectedLocation) {
                          break;
                        }
                        start = Math.max(1, 2 * expectedLocation - bestLocation);
                      }
                    }
                  }
                  const score = computeScore$1(pattern, {
                    errors: i + 1,
                    currentLocation: expectedLocation,
                    expectedLocation,
                    distance,
                    ignoreLocation,
                  });
                  if (score > currentThreshold) {
                    break;
                  }
                  lastBitArr = bitArr;
                }
                const result = {
                  isMatch: bestLocation >= 0,
                  // Count exact matches (those with a score of 0) to be "almost" exact
                  score: Math.max(1e-3, finalScore),
                };
                if (computeMatches) {
                  const indices = convertMaskToIndices(matchMask, minMatchCharLength);
                  if (!indices.length) {
                    result.isMatch = false;
                  } else if (includeMatches) {
                    result.indices = indices;
                  }
                }
                return result;
              }
              function createPatternAlphabet(pattern) {
                const mask = {};
                for (let i = 0, len = pattern.length; i < len; i += 1) {
                  const char = pattern.charAt(i);
                  mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
                }
                return mask;
              }
              class BitapSearch {
                constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}) {
                  this.options = {
                    location,
                    threshold,
                    distance,
                    includeMatches,
                    findAllMatches,
                    minMatchCharLength,
                    isCaseSensitive,
                    ignoreLocation,
                  };
                  this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                  this.chunks = [];
                  if (!this.pattern.length) {
                    return;
                  }
                  const addChunk = (pattern2, startIndex) => {
                    this.chunks.push({
                      pattern: pattern2,
                      alphabet: createPatternAlphabet(pattern2),
                      startIndex,
                    });
                  };
                  const len = this.pattern.length;
                  if (len > MAX_BITS) {
                    let i = 0;
                    const remainder = len % MAX_BITS;
                    const end = len - remainder;
                    while (i < end) {
                      addChunk(this.pattern.substr(i, MAX_BITS), i);
                      i += MAX_BITS;
                    }
                    if (remainder) {
                      const startIndex = len - MAX_BITS;
                      addChunk(this.pattern.substr(startIndex), startIndex);
                    }
                  } else {
                    addChunk(this.pattern, 0);
                  }
                }

                searchIn(text) {
                  const { isCaseSensitive, includeMatches } = this.options;
                  if (!isCaseSensitive) {
                    text = text.toLowerCase();
                  }
                  if (this.pattern === text) {
                    const result2 = {
                      isMatch: true,
                      score: 0,
                    };
                    if (includeMatches) {
                      result2.indices = [[0, text.length - 1]];
                    }
                    return result2;
                  }
                  const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;
                  let allIndices = [];
                  let totalScore = 0;
                  let hasMatches = false;
                  this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
                    const { isMatch, score, indices } = search(text, pattern, alphabet, {
                      location: location + startIndex,
                      distance,
                      threshold,
                      findAllMatches,
                      minMatchCharLength,
                      includeMatches,
                      ignoreLocation,
                    });
                    if (isMatch) {
                      hasMatches = true;
                    }
                    totalScore += score;
                    if (isMatch && indices) {
                      allIndices = [...allIndices, ...indices];
                    }
                  });
                  const result = {
                    isMatch: hasMatches,
                    score: hasMatches ? totalScore / this.chunks.length : 1,
                  };
                  if (hasMatches && includeMatches) {
                    result.indices = allIndices;
                  }
                  return result;
                }
              }
              class BaseMatch {
                constructor(pattern) {
                  this.pattern = pattern;
                }

                static isMultiMatch(pattern) {
                  return getMatch(pattern, this.multiRegex);
                }

                static isSingleMatch(pattern) {
                  return getMatch(pattern, this.singleRegex);
                }

                search() {}
              }
              function getMatch(pattern, exp) {
                const matches = pattern.match(exp);
                return matches ? matches[1] : null;
              }
              class ExactMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "exact";
                }

                static get multiRegex() {
                  return /^="(.*)"$/;
                }

                static get singleRegex() {
                  return /^=(.*)$/;
                }

                search(text) {
                  const isMatch = text === this.pattern;
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices: [0, this.pattern.length - 1],
                  };
                }
              }
              class InverseExactMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "inverse-exact";
                }

                static get multiRegex() {
                  return /^!"(.*)"$/;
                }

                static get singleRegex() {
                  return /^!(.*)$/;
                }

                search(text) {
                  const index = text.indexOf(this.pattern);
                  const isMatch = index === -1;
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices: [0, text.length - 1],
                  };
                }
              }
              class PrefixExactMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "prefix-exact";
                }

                static get multiRegex() {
                  return /^\^"(.*)"$/;
                }

                static get singleRegex() {
                  return /^\^(.*)$/;
                }

                search(text) {
                  const isMatch = text.startsWith(this.pattern);
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices: [0, this.pattern.length - 1],
                  };
                }
              }
              class InversePrefixExactMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "inverse-prefix-exact";
                }

                static get multiRegex() {
                  return /^!\^"(.*)"$/;
                }

                static get singleRegex() {
                  return /^!\^(.*)$/;
                }

                search(text) {
                  const isMatch = !text.startsWith(this.pattern);
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices: [0, text.length - 1],
                  };
                }
              }
              class SuffixExactMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "suffix-exact";
                }

                static get multiRegex() {
                  return /^"(.*)"\$$/;
                }

                static get singleRegex() {
                  return /^(.*)\$$/;
                }

                search(text) {
                  const isMatch = text.endsWith(this.pattern);
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices: [text.length - this.pattern.length, text.length - 1],
                  };
                }
              }
              class InverseSuffixExactMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "inverse-suffix-exact";
                }

                static get multiRegex() {
                  return /^!"(.*)"\$$/;
                }

                static get singleRegex() {
                  return /^!(.*)\$$/;
                }

                search(text) {
                  const isMatch = !text.endsWith(this.pattern);
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices: [0, text.length - 1],
                  };
                }
              }
              class FuzzyMatch extends BaseMatch {
                constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}) {
                  super(pattern);
                  this._bitapSearch = new BitapSearch(pattern, {
                    location,
                    threshold,
                    distance,
                    includeMatches,
                    findAllMatches,
                    minMatchCharLength,
                    isCaseSensitive,
                    ignoreLocation,
                  });
                }

                static get type() {
                  return "fuzzy";
                }

                static get multiRegex() {
                  return /^"(.*)"$/;
                }

                static get singleRegex() {
                  return /^(.*)$/;
                }

                search(text) {
                  return this._bitapSearch.searchIn(text);
                }
              }
              class IncludeMatch extends BaseMatch {
                constructor(pattern) {
                  super(pattern);
                }

                static get type() {
                  return "include";
                }

                static get multiRegex() {
                  return /^'"(.*)"$/;
                }

                static get singleRegex() {
                  return /^'(.*)$/;
                }

                search(text) {
                  let location = 0;
                  let index;
                  const indices = [];
                  const patternLen = this.pattern.length;
                  while ((index = text.indexOf(this.pattern, location)) > -1) {
                    location = index + patternLen;
                    indices.push([index, location - 1]);
                  }
                  const isMatch = !!indices.length;
                  return {
                    isMatch,
                    score: isMatch ? 0 : 1,
                    indices,
                  };
                }
              }
              const searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
              const searchersLen = searchers.length;
              const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
              const OR_TOKEN = "|";
              function parseQuery(pattern, options = {}) {
                return pattern.split(OR_TOKEN).map((item) => {
                  const query = item
                    .trim()
                    .split(SPACE_RE)
                    .filter((item2) => item2 && !!item2.trim());
                  const results = [];
                  for (let i = 0, len = query.length; i < len; i += 1) {
                    const queryItem = query[i];
                    let found = false;
                    let idx = -1;
                    while (!found && ++idx < searchersLen) {
                      const searcher = searchers[idx];
                      const token = searcher.isMultiMatch(queryItem);
                      if (token) {
                        results.push(new searcher(token, options));
                        found = true;
                      }
                    }
                    if (found) {
                      continue;
                    }
                    idx = -1;
                    while (++idx < searchersLen) {
                      const searcher = searchers[idx];
                      const token = searcher.isSingleMatch(queryItem);
                      if (token) {
                        results.push(new searcher(token, options));
                        break;
                      }
                    }
                  }
                  return results;
                });
              }
              const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
              class ExtendedSearch {
                constructor(pattern, { isCaseSensitive = Config.isCaseSensitive, includeMatches = Config.includeMatches, minMatchCharLength = Config.minMatchCharLength, ignoreLocation = Config.ignoreLocation, findAllMatches = Config.findAllMatches, location = Config.location, threshold = Config.threshold, distance = Config.distance } = {}) {
                  this.query = null;
                  this.options = {
                    isCaseSensitive,
                    includeMatches,
                    minMatchCharLength,
                    findAllMatches,
                    ignoreLocation,
                    location,
                    threshold,
                    distance,
                  };
                  this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                  this.query = parseQuery(this.pattern, this.options);
                }

                static condition(_, options) {
                  return options.useExtendedSearch;
                }

                searchIn(text) {
                  const { query } = this;
                  if (!query) {
                    return {
                      isMatch: false,
                      score: 1,
                    };
                  }
                  const { includeMatches, isCaseSensitive } = this.options;
                  text = isCaseSensitive ? text : text.toLowerCase();
                  let numMatches = 0;
                  let allIndices = [];
                  let totalScore = 0;
                  for (let i = 0, qLen = query.length; i < qLen; i += 1) {
                    const searchers2 = query[i];
                    allIndices.length = 0;
                    numMatches = 0;
                    for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
                      const searcher = searchers2[j];
                      const { isMatch, indices, score } = searcher.search(text);
                      if (isMatch) {
                        numMatches += 1;
                        totalScore += score;
                        if (includeMatches) {
                          const { type } = searcher.constructor;
                          if (MultiMatchSet.has(type)) {
                            allIndices = [...allIndices, ...indices];
                          } else {
                            allIndices.push(indices);
                          }
                        }
                      } else {
                        totalScore = 0;
                        numMatches = 0;
                        allIndices.length = 0;
                        break;
                      }
                    }
                    if (numMatches) {
                      const result = {
                        isMatch: true,
                        score: totalScore / numMatches,
                      };
                      if (includeMatches) {
                        result.indices = allIndices;
                      }
                      return result;
                    }
                  }
                  return {
                    isMatch: false,
                    score: 1,
                  };
                }
              }
              const registeredSearchers = [];
              function register(...args) {
                registeredSearchers.push(...args);
              }
              function createSearcher(pattern, options) {
                for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
                  const searcherClass = registeredSearchers[i];
                  if (searcherClass.condition(pattern, options)) {
                    return new searcherClass(pattern, options);
                  }
                }
                return new BitapSearch(pattern, options);
              }
              const LogicalOperator = {
                AND: "$and",
                OR: "$or",
              };
              const KeyType = {
                PATH: "$path",
                PATTERN: "$val",
              };
              const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
              const isPath = (query) => !!query[KeyType.PATH];
              const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
              const convertToExplicit = (query) => ({
                [LogicalOperator.AND]: Object.keys(query).map((key) => ({
                  [key]: query[key],
                })),
              });
              function parse(query, options, { auto = true } = {}) {
                const next = (query2) => {
                  const keys = Object.keys(query2);
                  const isQueryPath = isPath(query2);
                  if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
                    return next(convertToExplicit(query2));
                  }
                  if (isLeaf(query2)) {
                    const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
                    const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
                    if (!isString(pattern)) {
                      throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
                    }
                    const obj = {
                      keyId: createKeyId(key),
                      pattern,
                    };
                    if (auto) {
                      obj.searcher = createSearcher(pattern, options);
                    }
                    return obj;
                  }
                  const node = {
                    children: [],
                    operator: keys[0],
                  };
                  keys.forEach((key) => {
                    const value = query2[key];
                    if (isArray(value)) {
                      value.forEach((item) => {
                        node.children.push(next(item));
                      });
                    }
                  });
                  return node;
                };
                if (!isExpression(query)) {
                  query = convertToExplicit(query);
                }
                return next(query);
              }
              function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
                results.forEach((result) => {
                  let totalScore = 1;
                  result.matches.forEach(({ key, norm: norm2, score }) => {
                    const weight = key ? key.weight : null;
                    totalScore *= (score === 0 && weight ? Number.EPSILON : score) ** ((weight || 1) * (ignoreFieldNorm ? 1 : norm2));
                  });
                  result.score = totalScore;
                });
              }
              function transformMatches(result, data) {
                const { matches } = result;
                data.matches = [];
                if (!isDefined(matches)) {
                  return;
                }
                matches.forEach((match) => {
                  if (!isDefined(match.indices) || !match.indices.length) {
                    return;
                  }
                  const { indices, value } = match;
                  const obj = {
                    indices,
                    value,
                  };
                  if (match.key) {
                    obj.key = match.key.src;
                  }
                  if (match.idx > -1) {
                    obj.refIndex = match.idx;
                  }
                  data.matches.push(obj);
                });
              }
              function transformScore(result, data) {
                data.score = result.score;
              }
              function format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {
                const transformers = [];
                if (includeMatches) transformers.push(transformMatches);
                if (includeScore) transformers.push(transformScore);
                return results.map((result) => {
                  const { idx } = result;
                  const data = {
                    item: docs[idx],
                    refIndex: idx,
                  };
                  if (transformers.length) {
                    transformers.forEach((transformer) => {
                      transformer(result, data);
                    });
                  }
                  return data;
                });
              }
              class Fuse {
                constructor(docs, options = {}, index) {
                  this.options = { ...Config, ...options };
                  if (this.options.useExtendedSearch && false);
                  this._keyStore = new KeyStore(this.options.keys);
                  this.setCollection(docs, index);
                }

                setCollection(docs, index) {
                  this._docs = docs;
                  if (index && !(index instanceof FuseIndex)) {
                    throw new Error(INCORRECT_INDEX_TYPE);
                  }
                  this._myIndex =
                    index ||
                    createIndex(this.options.keys, this._docs, {
                      getFn: this.options.getFn,
                      fieldNormWeight: this.options.fieldNormWeight,
                    });
                }

                add(doc) {
                  if (!isDefined(doc)) {
                    return;
                  }
                  this._docs.push(doc);
                  this._myIndex.add(doc);
                }

                remove(predicate = () => false) {
                  const results = [];
                  for (let i = 0, len = this._docs.length; i < len; i += 1) {
                    const doc = this._docs[i];
                    if (predicate(doc, i)) {
                      this.removeAt(i);
                      i -= 1;
                      len -= 1;
                      results.push(doc);
                    }
                  }
                  return results;
                }

                removeAt(idx) {
                  this._docs.splice(idx, 1);
                  this._myIndex.removeAt(idx);
                }

                getIndex() {
                  return this._myIndex;
                }

                search(query, { limit = -1 } = {}) {
                  const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;
                  let results = isString(query) ? (isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query)) : this._searchLogical(query);
                  computeScore(results, { ignoreFieldNorm });
                  if (shouldSort) {
                    results.sort(sortFn);
                  }
                  if (isNumber(limit) && limit > -1) {
                    results = results.slice(0, limit);
                  }
                  return format(results, this._docs, {
                    includeMatches,
                    includeScore,
                  });
                }

                _searchStringList(query) {
                  const searcher = createSearcher(query, this.options);
                  const { records } = this._myIndex;
                  const results = [];
                  records.forEach(({ v: text, i: idx, n: norm2 }) => {
                    if (!isDefined(text)) {
                      return;
                    }
                    const { isMatch, score, indices } = searcher.searchIn(text);
                    if (isMatch) {
                      results.push({
                        item: text,
                        idx,
                        matches: [{ score, value: text, norm: norm2, indices }],
                      });
                    }
                  });
                  return results;
                }

                _searchLogical(query) {
                  const expression = parse(query, this.options);
                  const evaluate = (node, item, idx) => {
                    if (!node.children) {
                      const { keyId, searcher } = node;
                      const matches = this._findMatches({
                        key: this._keyStore.get(keyId),
                        value: this._myIndex.getValueForItemAtKeyId(item, keyId),
                        searcher,
                      });
                      if (matches && matches.length) {
                        return [
                          {
                            idx,
                            item,
                            matches,
                          },
                        ];
                      }
                      return [];
                    }
                    const res = [];
                    for (let i = 0, len = node.children.length; i < len; i += 1) {
                      const child = node.children[i];
                      const result = evaluate(child, item, idx);
                      if (result.length) {
                        res.push(...result);
                      } else if (node.operator === LogicalOperator.AND) {
                        return [];
                      }
                    }
                    return res;
                  };
                  const { records } = this._myIndex;
                  const resultMap = {};
                  const results = [];
                  records.forEach(({ $: item, i: idx }) => {
                    if (isDefined(item)) {
                      const expResults = evaluate(expression, item, idx);
                      if (expResults.length) {
                        if (!resultMap[idx]) {
                          resultMap[idx] = { idx, item, matches: [] };
                          results.push(resultMap[idx]);
                        }
                        expResults.forEach(({ matches }) => {
                          resultMap[idx].matches.push(...matches);
                        });
                      }
                    }
                  });
                  return results;
                }

                _searchObjectList(query) {
                  const searcher = createSearcher(query, this.options);
                  const { keys, records } = this._myIndex;
                  const results = [];
                  records.forEach(({ $: item, i: idx }) => {
                    if (!isDefined(item)) {
                      return;
                    }
                    const matches = [];
                    keys.forEach((key, keyIndex) => {
                      matches.push(
                        ...this._findMatches({
                          key,
                          value: item[keyIndex],
                          searcher,
                        }),
                      );
                    });
                    if (matches.length) {
                      results.push({
                        idx,
                        item,
                        matches,
                      });
                    }
                  });
                  return results;
                }

                _findMatches({ key, value, searcher }) {
                  if (!isDefined(value)) {
                    return [];
                  }
                  const matches = [];
                  if (isArray(value)) {
                    value.forEach(({ v: text, i: idx, n: norm2 }) => {
                      if (!isDefined(text)) {
                        return;
                      }
                      const { isMatch, score, indices } = searcher.searchIn(text);
                      if (isMatch) {
                        matches.push({
                          score,
                          key,
                          value: text,
                          idx,
                          norm: norm2,
                          indices,
                        });
                      }
                    });
                  } else {
                    const { v: text, n: norm2 } = value;
                    const { isMatch, score, indices } = searcher.searchIn(text);
                    if (isMatch) {
                      matches.push({ score, key, value: text, norm: norm2, indices });
                    }
                  }
                  return matches;
                }
              }
              Fuse.version = "6.6.2";
              Fuse.createIndex = createIndex;
              Fuse.parseIndex = parseIndex;
              Fuse.config = Config;
              {
                Fuse.parseQuery = parse;
              }
              {
                register(ExtendedSearch);
              }
            },
          /***/
          791:
            /***/
            function (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
              __webpack_require__2.r(__webpack_exports__2);
              __webpack_require__2.d(__webpack_exports__2, {
                __DO_NOT_USE__ActionTypes() {
                  return (
                    /* binding */
                    ActionTypes
                  );
                },
                applyMiddleware() {
                  return (
                    /* binding */
                    applyMiddleware
                  );
                },
                bindActionCreators() {
                  return (
                    /* binding */
                    bindActionCreators
                  );
                },
                combineReducers() {
                  return (
                    /* binding */
                    combineReducers
                  );
                },
                compose() {
                  return (
                    /* binding */
                    compose
                  );
                },
                createStore() {
                  return (
                    /* binding */
                    createStore
                  );
                },
                legacy_createStore() {
                  return (
                    /* binding */
                    legacy_createStore
                  );
                },
              });
              function _typeof(obj) {
                "@babel/helpers - typeof";

                return (
                  (_typeof =
                    typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
                      ? function (obj2) {
                          return typeof obj2;
                        }
                      : function (obj2) {
                          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                        }),
                  _typeof(obj)
                );
              }
              function _toPrimitive(input, hint) {
                if (_typeof(input) !== "object" || input === null) return input;
                const prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  const res = prim.call(input, hint || "default");
                  if (_typeof(res) !== "object") return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              function _toPropertyKey(arg) {
                const key = _toPrimitive(arg, "string");
                return _typeof(key) === "symbol" ? key : String(key);
              }
              function _defineProperty(obj, key, value) {
                key = _toPropertyKey(key);
                if (key in obj) {
                  Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true,
                  });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function ownKeys(object, enumerableOnly) {
                const keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                  let symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly &&
                    (symbols = symbols.filter(function (sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    })),
                    keys.push.apply(keys, symbols);
                }
                return keys;
              }
              function _objectSpread2(target) {
                for (let i = 1; i < arguments.length; i++) {
                  var source = arguments[i] != null ? arguments[i] : {};
                  i % 2
                    ? ownKeys(Object(source), true).forEach(function (key) {
                        _defineProperty(target, key, source[key]);
                      })
                    : Object.getOwnPropertyDescriptors
                    ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
                    : ownKeys(Object(source)).forEach(function (key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                      });
                }
                return target;
              }
              function formatProdErrorMessage(code) {
                return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
              }
              const $$observable = (function () {
                return (typeof Symbol === "function" && Symbol.observable) || "@@observable";
              })();
              const randomString = function randomString2() {
                return Math.random().toString(36).substring(7).split("").join(".");
              };
              var ActionTypes = {
                INIT: `@@redux/INIT${randomString()}`,
                REPLACE: `@@redux/REPLACE${randomString()}`,
                PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
                  return `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`;
                },
              };
              function isPlainObject(obj) {
                if (typeof obj !== "object" || obj === null) return false;
                let proto = obj;
                while (Object.getPrototypeOf(proto) !== null) {
                  proto = Object.getPrototypeOf(proto);
                }
                return Object.getPrototypeOf(obj) === proto;
              }
              function createStore(reducer, preloadedState, enhancer) {
                let _ref2;
                if ((typeof preloadedState === "function" && typeof enhancer === "function") || (typeof enhancer === "function" && typeof arguments[3] === "function")) {
                  throw new Error(formatProdErrorMessage(0));
                }
                if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
                  enhancer = preloadedState;
                  preloadedState = void 0;
                }
                if (typeof enhancer !== "undefined") {
                  if (typeof enhancer !== "function") {
                    throw new Error(formatProdErrorMessage(1));
                  }
                  return enhancer(createStore)(reducer, preloadedState);
                }
                if (typeof reducer !== "function") {
                  throw new Error(formatProdErrorMessage(2));
                }
                let currentReducer = reducer;
                let currentState = preloadedState;
                let currentListeners = [];
                let nextListeners = currentListeners;
                let isDispatching = false;
                function ensureCanMutateNextListeners() {
                  if (nextListeners === currentListeners) {
                    nextListeners = currentListeners.slice();
                  }
                }
                function getState() {
                  if (isDispatching) {
                    throw new Error(formatProdErrorMessage(3));
                  }
                  return currentState;
                }
                function subscribe(listener) {
                  if (typeof listener !== "function") {
                    throw new Error(formatProdErrorMessage(4));
                  }
                  if (isDispatching) {
                    throw new Error(formatProdErrorMessage(5));
                  }
                  let isSubscribed = true;
                  ensureCanMutateNextListeners();
                  nextListeners.push(listener);
                  return function unsubscribe() {
                    if (!isSubscribed) {
                      return;
                    }
                    if (isDispatching) {
                      throw new Error(formatProdErrorMessage(6));
                    }
                    isSubscribed = false;
                    ensureCanMutateNextListeners();
                    const index = nextListeners.indexOf(listener);
                    nextListeners.splice(index, 1);
                    currentListeners = null;
                  };
                }
                function dispatch(action) {
                  if (!isPlainObject(action)) {
                    throw new Error(formatProdErrorMessage(7));
                  }
                  if (typeof action.type === "undefined") {
                    throw new Error(formatProdErrorMessage(8));
                  }
                  if (isDispatching) {
                    throw new Error(formatProdErrorMessage(9));
                  }
                  try {
                    isDispatching = true;
                    currentState = currentReducer(currentState, action);
                  } finally {
                    isDispatching = false;
                  }
                  const listeners = (currentListeners = nextListeners);
                  for (let i = 0; i < listeners.length; i++) {
                    const listener = listeners[i];
                    listener();
                  }
                  return action;
                }
                function replaceReducer(nextReducer) {
                  if (typeof nextReducer !== "function") {
                    throw new Error(formatProdErrorMessage(10));
                  }
                  currentReducer = nextReducer;
                  dispatch({
                    type: ActionTypes.REPLACE,
                  });
                }
                function observable() {
                  let _ref;
                  const outerSubscribe = subscribe;
                  return (
                    (_ref = {
                      /**
                       * The minimal observable subscription method.
                       * @param {Object} observer Any object that can be used as an observer.
                       * The observer object should have a `next` method.
                       * @return {subscription} An object with an `unsubscribe` method that can
                       * be used to unsubscribe the observable from the store, and prevent further
                       * emission of values from the observable.
                       */
                      subscribe: function subscribe2(observer) {
                        if (typeof observer !== "object" || observer === null) {
                          throw new Error(formatProdErrorMessage(11));
                        }
                        function observeState() {
                          if (observer.next) {
                            observer.next(getState());
                          }
                        }
                        observeState();
                        const unsubscribe = outerSubscribe(observeState);
                        return {
                          unsubscribe,
                        };
                      },
                    }),
                    (_ref[$$observable] = function () {
                      return this;
                    }),
                    _ref
                  );
                }
                dispatch({
                  type: ActionTypes.INIT,
                });
                return (
                  (_ref2 = {
                    dispatch,
                    subscribe,
                    getState,
                    replaceReducer,
                  }),
                  (_ref2[$$observable] = observable),
                  _ref2
                );
              }
              var legacy_createStore = createStore;
              function assertReducerShape(reducers) {
                Object.keys(reducers).forEach(function (key) {
                  const reducer = reducers[key];
                  const initialState = reducer(void 0, {
                    type: ActionTypes.INIT,
                  });
                  if (typeof initialState === "undefined") {
                    throw new Error(formatProdErrorMessage(12));
                  }
                  if (
                    typeof reducer(void 0, {
                      type: ActionTypes.PROBE_UNKNOWN_ACTION(),
                    }) === "undefined"
                  ) {
                    throw new Error(formatProdErrorMessage(13));
                  }
                });
              }
              function combineReducers(reducers) {
                const reducerKeys = Object.keys(reducers);
                const finalReducers = {};
                for (let i = 0; i < reducerKeys.length; i++) {
                  const key = reducerKeys[i];
                  if (typeof reducers[key] === "function") {
                    finalReducers[key] = reducers[key];
                  }
                }
                const finalReducerKeys = Object.keys(finalReducers);
                let shapeAssertionError;
                try {
                  assertReducerShape(finalReducers);
                } catch (e) {
                  shapeAssertionError = e;
                }
                return function combination(state, action) {
                  if (state === void 0) {
                    state = {};
                  }
                  if (shapeAssertionError) {
                    throw shapeAssertionError;
                  }
                  let hasChanged = false;
                  const nextState = {};
                  for (let _i = 0; _i < finalReducerKeys.length; _i++) {
                    const _key = finalReducerKeys[_i];
                    const reducer = finalReducers[_key];
                    const previousStateForKey = state[_key];
                    const nextStateForKey = reducer(previousStateForKey, action);
                    if (typeof nextStateForKey === "undefined") {
                      action && action.type;
                      throw new Error(formatProdErrorMessage(14));
                    }
                    nextState[_key] = nextStateForKey;
                    hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                  }
                  hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
                  return hasChanged ? nextState : state;
                };
              }
              function bindActionCreator(actionCreator, dispatch) {
                return function () {
                  return dispatch(actionCreator.apply(this, arguments));
                };
              }
              function bindActionCreators(actionCreators, dispatch) {
                if (typeof actionCreators === "function") {
                  return bindActionCreator(actionCreators, dispatch);
                }
                if (typeof actionCreators !== "object" || actionCreators === null) {
                  throw new Error(formatProdErrorMessage(16));
                }
                const boundActionCreators = {};
                for (const key in actionCreators) {
                  const actionCreator = actionCreators[key];
                  if (typeof actionCreator === "function") {
                    boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
                  }
                }
                return boundActionCreators;
              }
              function compose() {
                for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
                  funcs[_key] = arguments[_key];
                }
                if (funcs.length === 0) {
                  return function (arg) {
                    return arg;
                  };
                }
                if (funcs.length === 1) {
                  return funcs[0];
                }
                return funcs.reduce(function (a, b) {
                  return function () {
                    return a(b.apply(void 0, arguments));
                  };
                });
              }
              function applyMiddleware() {
                for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
                  middlewares[_key] = arguments[_key];
                }
                return function (createStore2) {
                  return function () {
                    const store = createStore2.apply(void 0, arguments);
                    let _dispatch = function dispatch() {
                      throw new Error(formatProdErrorMessage(15));
                    };
                    const middlewareAPI = {
                      getState: store.getState,
                      dispatch: function dispatch() {
                        return _dispatch.apply(void 0, arguments);
                      },
                    };
                    const chain = middlewares.map(function (middleware) {
                      return middleware(middlewareAPI);
                    });
                    _dispatch = compose.apply(void 0, chain)(store.dispatch);
                    return _objectSpread2(
                      _objectSpread2({}, store),
                      {},
                      {
                        dispatch: _dispatch,
                      },
                    );
                  };
                };
              }
            },
          /** *** */
        };
        const __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          const cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          const module2 = (__webpack_module_cache__[moduleId] = {
            /** *** */
            // no module.id needed
            /** *** */
            // no module.loaded needed
            /** *** */
            exports: {},
            /** *** */
          });
          __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        !(function () {
          __webpack_require__.n = function (module2) {
            const getter =
              module2 && module2.__esModule
                ? /** *** */
                  function () {
                    return module2.default;
                  }
                : /** *** */
                  function () {
                    return module2;
                  };
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        })();
        !(function () {
          __webpack_require__.d = function (exports2, definition) {
            for (const key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        })();
        !(function () {
          __webpack_require__.o = function (obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        })();
        !(function () {
          __webpack_require__.r = function (exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
        })();
        let __webpack_exports__ = {};
        !(function () {
          const _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);
          const _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);
          __webpack_require__(187);
          __webpack_require__(883);
          __webpack_require__(789);
          __webpack_require__(686);
          __webpack_exports__.default = _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default();
        })();
        __webpack_exports__ = __webpack_exports__.default;
        return __webpack_exports__;
      })()
    );
  });
})(choices);
const Choices = /* @__PURE__ */ getDefaultExportFromCjs(choicesExports);
window.Choices = Choices;
